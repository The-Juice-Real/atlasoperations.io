<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>SAT Trig — Visual → Concept → Math → SAT (v2.2)</title>
  <title>SAT Trig — Visual → Concept → Math → SAT (v2.2 + Glossary)</title>
  <style>
    :root{
      --bg:#050505; --panel:#0a0a0a; --text:#eee; --muted:#8a8a8a;
      --sin:#ff0055; --cos:#00ccff; --tan:#ffcc00;
      --sec:#ccffff; --csc:#ffcccc; --cot:#ff8800;
      --ok:#22c55e; --bad:#ef4444; --vio:#bd00ff;
      --grid:#222; --line:#2a2a2a;
    }
    *{box-sizing:border-box}
    body{
      margin:0; height:100vh; width:100vw;
      background:var(--bg); color:var(--text);
      font-family: "Segoe UI", system-ui, sans-serif;
      display:flex; overflow:hidden;
    }

    /* LEFT STAGE */
    #stage{
      flex:1; min-width:0; position:relative; background:#000; overflow:hidden;
      cursor:crosshair;
    }
    canvas{display:block; width:100%; height:100%}

    /* HUD */
    #hud{
      position:absolute; top:14px; left:14px; z-index:20;
      background:rgba(10,10,10,.82);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 12px;
      display:flex; gap:10px; align-items:flex-start;
      backdrop-filter: blur(6px);
      max-width: 92%;
    }
    #hud .k{font-size:.72rem; letter-spacing:1.5px; text-transform:uppercase; color:#777}
    #hud .v{font-weight:950; font-size:1.02rem; line-height:1.2}
    #hud .s{font-size:.85rem; color:#aaa; margin-top:2px}
    .pill{
      padding:6px 10px; border-radius:999px;
      border:1px solid #333; background:rgba(255,255,255,.05);
      color:#ddd; font-weight:900; font-size:.72rem;
      user-select:none;
      white-space:nowrap;
    }
    .pill.ok{border-color:rgba(34,197,94,.45); color:#c7f9d6}
    .pill.bad{border-color:rgba(239,68,68,.45); color:#ffd1d1}

    /* Micro toggles */
    #microbar{
      position:absolute; top:14px; right:14px; z-index:20;
      background:rgba(10,10,10,.82);
      border:1px solid var(--line);
      border-radius:12px;
      padding:8px 10px;
      display:flex; gap:8px; align-items:center;
      backdrop-filter: blur(6px);
    }
    #microbar button{
      border:none; cursor:pointer;
      padding:8px 10px; border-radius:10px;
      background:rgba(255,255,255,.06);
      color:#ddd; font-weight:950; font-size:.75rem;
    }
    #microbar button.active{ background:#fff; color:#000; }
    #microbar button:disabled{ opacity:.45; cursor:not-allowed; }

    /* BOTTOM NAV */
    #nav{
      position:absolute; bottom:16px; left:50%; transform:translateX(-50%);
      z-index:20; display:flex; gap:8px;
      background:rgba(10,10,10,.90);
      border:1px solid #333;
      border-radius:16px;
      padding:10px;
      max-width:95%;
      overflow-x:auto; white-space:nowrap; scrollbar-width:none;
    }
    #nav::-webkit-scrollbar{display:none}
    #nav button{
      border:none; cursor:pointer;
      padding:9px 12px; border-radius:12px;
      background:transparent; color:#888;
      font-weight:950; letter-spacing:.4px; text-transform:uppercase;
      font-size:.72rem;
      transition:.15s;
    }
    #nav button:hover{color:#fff; background:rgba(255,255,255,.08)}
    #nav button.active{background:#fff; color:#000}
    #nav button:disabled{opacity:.45; cursor:not-allowed}

    /* RIGHT PANEL */
    #panel{
      width:480px; flex-shrink:0;
      background:var(--panel);
      border-left:1px solid #222;
      display:flex; flex-direction:column;
      position:relative;
    }
    #panelTop{
      padding:18px 18px 12px 18px;
      border-bottom:1px solid #1f1f1f;
    }
    #title{
      margin:0; font-size:1.45rem; letter-spacing:-.5px; line-height:1.15;
      font-weight:980;
    }
    #subtitle{
      margin:8px 0 0 0;
      color:#8f8f8f; font-size:.92rem; line-height:1.35;
    }

    #layers{
      margin-top:12px;
      display:grid; grid-template-columns:repeat(4,1fr); gap:8px;
    }
    #layers button{
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:10px 8px;
      background:#070707;
      color:#bbb;
      font-weight:980;
      font-size:.72rem;
      letter-spacing:1.4px;
      text-transform:uppercase;
      cursor:pointer;
    }
    #layers button.active{
      background:#fff; color:#000; border-color:#fff;
    }
    #layers button.locked{opacity:.35; cursor:not-allowed}
    #layers button:disabled{opacity:.35; cursor:not-allowed}

    #body{
      padding:16px 18px 18px 18px;
      overflow:auto;
      flex:1;
    }
    p{margin:0 0 12px 0; color:#c0c0c0; line-height:1.62; font-size:.95rem}
    strong{color:#fff}
    ul{margin:0 0 12px 18px; color:#c0c0c0}
    li{margin:6px 0}
    .box{
      border:1px solid #2b2b2b;
      background:rgba(255,255,255,.05);
      border-radius:14px;
      padding:12px 12px;
      margin:12px 0;
    }
    .box.ok{border-color:rgba(34,197,94,.35); background:rgba(34,197,94,.07)}
    .box.bad{border-color:rgba(239,68,68,.35); background:rgba(239,68,68,.07)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace}
    .tag{
      display:inline-block; padding:2px 8px; border-radius:999px;
      background:rgba(255,255,255,.07); border:1px solid #2b2b2b;
      color:#ddd; font-weight:950; font-size:.74rem; letter-spacing:.4px;
    }
    .sat{
      border:1px solid #2b2b2b;
      background:#060606;
      border-radius:14px;
      padding:12px;
    }
    .sat .q{ color:#e8e8e8; font-weight:980; margin-bottom:8px; }
    .sat .a{ color:#bdbdbd; font-size:.92rem; line-height:1.55; }
    .sat .map{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #232323;
      background:rgba(255,255,255,.04);
      color:#cfcfcf;
    }

    #panelBottom{
      padding:12px 18px;
      border-top:1px solid #1f1f1f;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    #panelBottom .left, #panelBottom .right{display:flex; gap:10px}
    #panelBottom button{
      border:none; cursor:pointer;
      padding:10px 12px; border-radius:12px;
      background:rgba(255,255,255,.08); color:#ddd; font-weight:980;
    }
    #panelBottom button.primary{ background:#fff; color:#000; }
    #panelBottom button:disabled{ opacity:.35; cursor:not-allowed; }

    /* QUIZ OVERLAY */
    #quizOverlay{
      position:absolute; inset:0;
      background:rgba(0,0,0,0.88);
      display:none;
      z-index:999;
      padding:18px;
    }
    #quizOverlay.active{display:flex; align-items:center; justify-content:center;}
    #quizCard{
      width:100%;
      max-width:440px;
      border-radius:16px;
      border:1px solid #2b2b2b;
      background:rgba(10,10,10,0.94);
      box-shadow: 0 0 40px rgba(0,0,0,0.55);
      padding:14px;
    }
    #quizTop{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; margin-bottom:10px;
    }
    #quizTitle{
      font-weight:1000; letter-spacing:1.2px;
      text-transform:uppercase; font-size:.78rem;
      color:#ddd;
    }
    #quizTime{
      font-weight:1000; font-size:.82rem; color:#fff;
      padding:6px 10px; border-radius:999px;
      border:1px solid #2b2b2b;
      background:rgba(255,255,255,0.06);
      min-width:74px;
      text-align:center;
    }
    #quizBarWrap{
      flex:1;
      height:10px;
      border-radius:999px;
      background:#151515;
      border:1px solid #222;
      overflow:hidden;
    }
    #quizBar{
      height:100%;
      width:100%;
      background:rgba(34,197,94,0.85);
      transition: width .08s linear;
    }
    #quizQ{
      margin:10px 0 12px 0;
      font-weight:980;
      color:#f0f0f0;
      line-height:1.35;
      font-size:1.02rem;
    }
    #quizChoices{
      display:grid;
      gap:8px;
      margin-bottom:10px;
    }
    .choice{
      border:1px solid #2b2b2b;
      background:rgba(255,255,255,0.05);
      padding:10px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:950;
      color:#ddd;
      text-align:left;
    }
    .choice:hover{border-color:#fff; background:rgba(255,255,255,0.09)}
    .choice:disabled{opacity:.5; cursor:not-allowed}
    #quizResult{
      min-height:22px;
      font-weight:1000;
      letter-spacing:.2px;
    }
    #quizHint{
      margin-top:10px;
      color:#aaa;
      font-size:.86rem;
      line-height:1.4;
      border-top:1px solid #1f1f1f;
      padding-top:10px;
    }
    .good{color:var(--ok)}
    .bad{color:var(--bad)}

    /* =========================================================
       GLOSSARY MODAL (Must-memorize popup)
       ========================================================= */
    #glossaryModal{
      position:fixed;
      inset:0;
      z-index:950; /* below quiz (999) */
      display:none;
    }
    #glossaryModal.active{display:block;}
    .g_backdrop{
      position:absolute; inset:0;
      background:rgba(0,0,0,0.78);
    }
    .g_card{
      position:relative;
      width:min(980px, calc(100vw - 24px));
      height:min(86vh, 760px);
      margin:60px auto;
      border-radius:16px;
      border:1px solid #2b2b2b;
      background:rgba(10,10,10,0.96);
      box-shadow: 0 0 40px rgba(0,0,0,0.60);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .g_header{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:14px 16px;
      border-bottom:1px solid #1f1f1f;
    }
    .g_title{
      font-weight:1000;
      letter-spacing:.2px;
      font-size:1.08rem;
      color:#fff;
      line-height:1.15;
    }
    .g_sub{
      margin-top:4px;
      color:#888;
      font-size:.86rem;
      line-height:1.35;
    }
    .g_close{
      border:none; cursor:pointer;
      padding:8px 10px; border-radius:12px;
      background:rgba(255,255,255,.08); color:#ddd; font-weight:980;
    }
    .g_close:hover{background:rgba(255,255,255,.12)}
    .g_search{
      padding:12px 16px;
      border-bottom:1px solid #1f1f1f;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    #g_searchInput{
      flex:1;
      min-width:220px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid #2b2b2b;
      background:#060606;
      color:#eee;
      outline:none;
      font-weight:700;
    }
    .g_hint{
      color:#777;
      font-size:.85rem;
    }
    .g_hint kbd{
      background:#060606;
      border:1px solid #2b2b2b;
      border-bottom-width:2px;
      padding:2px 6px;
      border-radius:6px;
      color:#ddd;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    .g_body{
      padding:14px 16px 18px 16px;
      overflow:auto;
    }
    .g_section{margin:10px 0 18px 0;}
    .g_section h3{
      margin: 0 0 10px 0;
      font-size: .95rem;
      letter-spacing: 1.2px;
      text-transform: uppercase;
      color:#ddd;
      font-weight:1000;
    }
    .g_grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap:10px;
    }
    .g_box{
      border:1px solid #2b2b2b;
      background:rgba(255,255,255,.05);
      border-radius:14px;
      padding:12px 12px;
    }
    .g_box.ok{border-color:rgba(34,197,94,.35); background:rgba(34,197,94,.07)}
    .g_box.bad{border-color:rgba(239,68,68,.35); background:rgba(239,68,68,.07)}
    .g_box h4{
      margin:0 0 8px 0;
      font-size:.95rem;
      color:#fff;
      font-weight:1000;
      letter-spacing:-.2px;
    }
    .g_line{
      margin:6px 0;
      color:#bbb;
      line-height:1.55;
      font-size:.94rem;
    }
    .g_k{ color:#888; font-weight:900; }
    .g_v{ color:#fff; font-weight:1000; }
    .g_note{ margin-top:8px; color:#888; font-size:.9rem; line-height:1.5; }

    .g_tableWrap{ margin-top: 10px; }
    .g_table{
      width:100%;
      border-collapse: collapse;
      background:#060606;
      border:1px solid #2b2b2b;
      border-radius:14px;
      overflow:hidden;
    }
    .g_table th, .g_table td{
      padding:10px;
      border-bottom:1px solid #1f1f1f;
      text-align:center;
      color:#ddd;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size:.9rem;
    }
    .g_table th{
      color:#fff;
      background:rgba(255,255,255,.06);
      font-weight:1000;
    }
    .g_warn{ color: var(--tan); font-weight:1000; }

    @media (max-width: 820px){
      body{flex-direction:column}
      #panel{width:100%; height:52%}
      #stage{height:48%}
      #microbar{top:64px}
      .g_card{ margin: 12px auto; height: calc(92vh); }
    }
  </style>
</head>
<body>

<div id="stage">
  <canvas id="cvs"></canvas>

  <div id="hud">
    <div>
      <div class="k">ANGLE</div>
      <div class="v" id="hudTheta">θ = 0° (0)</div>
      <div class="s" id="hudEq">Equivalent: 0°</div>
    </div>
    <div class="pill ok" id="hudQuad">QI</div>
    <div class="pill" id="hudRef">ref 0°</div>
  </div>

  <div id="microbar">
    <button id="btnReadout" class="active" title="Tiny values near the point">READOUT</button>
    <button id="btnSnap" class="" title="Snap to SAT special angles">SNAP</button>
    <button id="btnGlossary" class="" title="Must-memorize values + formulas (G)">GLOSSARY</button>
  </div>

  <div id="nav"></div>
</div>

<div id="panel">
  <!-- QUIZ OVERLAY -->
  <div id="quizOverlay">
    <div id="quizCard">
      <div id="quizTop">
        <div id="quizTitle">SAT CHECK</div>
        <div id="quizBarWrap"><div id="quizBar"></div></div>
        <div id="quizTime">12.0s</div>
      </div>

      <div id="quizQ"></div>
      <div id="quizChoices"></div>
      <div id="quizResult"></div>

      <div id="quizHint">
        SAT trig is not “reading.” It’s fast mapping.  
        Miss or timeout → you drop one step. Then you earn SAT again.
      </div>
    </div>
  </div>

  <div id="panelTop">
    <h1 id="title"></h1>
    <div id="subtitle"></div>

    <div id="layers">
      <button id="layer0" onclick="setLayer(0)">1 Visual</button>
      <button id="layer1" onclick="setLayer(1)">2 Concept</button>
      <button id="layer2" onclick="setLayer(2)">3 Math</button>
      <button id="layer3" onclick="setLayer(3)">4 SAT</button>
    </div>
  </div>

  <div id="body"></div>

  <div id="panelBottom">
    <div class="left">
      <button id="btnPrev" onclick="prevLesson()">Prev</button>
      <button id="btnNext" onclick="nextLesson()">Next</button>
    </div>
    <div class="right">
      <button id="btnBackLayer" onclick="prevLayer()">Back Step</button>
      <button class="primary" id="btnForwardLayer" onclick="nextLayer()">Next Step</button>
    </div>
  </div>
</div>

<!-- =========================================================
     GLOSSARY MODAL (Popup)
     ========================================================= -->
<div id="glossaryModal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="g_backdrop" id="g_backdrop"></div>

  <div class="g_card" role="document">
    <div class="g_header">
      <div>
        <div class="g_title">Must-Memorize Glossary</div>
        <div class="g_sub">Open anytime. Search anytime. This is the SAT “memory kit.”</div>
      </div>
      <button class="g_close" id="g_closeBtn" aria-label="Close glossary">✕</button>
    </div>

    <div class="g_search">
      <input id="g_searchInput" type="text" placeholder="Search: 30°, π/6, reference angle, SOHCAHTOA, s=rθ…" />
      <div class="g_hint">Shortcuts: <kbd>G</kbd> open/close • <kbd>Esc</kbd> close</div>
    </div>

    <div class="g_body" id="g_body">
      <div class="g_section" data-tags="must memorize core kit values special angles triangles unit circle signs">
        <h3>1) The tiny list that carries the whole SAT</h3>

        <div class="g_grid">
          <div class="g_box ok" data-tags="unit circle meaning x y equals cos sin point coordinates">
            <h4>Unit circle translation</h4>
            <div class="g_line"><span class="g_k">Point:</span> <span class="g_v mono">(x, y)</span></div>
            <div class="g_line"><span class="g_k">Means:</span> <span class="g_v mono">(cos θ, sin θ)</span></div>
            <div class="g_note">SAT often “gives you cos and sin” by handing you the point.</div>
          </div>

          <div class="g_box" data-tags="degrees radians conversion 180 pi 360 2pi 90 pi/2">
            <h4>Degrees ↔ radians</h4>
            <div class="g_line"><span class="g_k">Anchor:</span> <span class="g_v mono">180° = π</span></div>
            <div class="g_line"><span class="g_k">So:</span> <span class="g_v mono">30°=π/6 • 45°=π/4 • 60°=π/3 • 90°=π/2</span></div>
            <div class="g_note">If you remember one thing: remember 180° = π.</div>
          </div>

          <div class="g_box" data-tags="triangles 30-60-90 45-45-90 ratios root2 root3">
            <h4>The two triangles</h4>
            <div class="g_line"><span class="g_k">45-45-90:</span> <span class="g_v mono">1 : 1 : √2</span></div>
            <div class="g_line"><span class="g_k">30-60-90:</span> <span class="g_v mono">1 : √3 : 2</span></div>
            <div class="g_note">All “special angle” values come from these + signs.</div>
          </div>

          <div class="g_box" data-tags="quadrants signs sin cos tan positive negative">
            <h4>Quadrant signs (look at x and y)</h4>
            <div class="g_line"><span class="g_k">QI:</span> <span class="g_v mono">cos +, sin +</span></div>
            <div class="g_line"><span class="g_k">QII:</span> <span class="g_v mono">cos −, sin +</span></div>
            <div class="g_line"><span class="g_k">QIII:</span> <span class="g_v mono">cos −, sin −</span></div>
            <div class="g_line"><span class="g_k">QIV:</span> <span class="g_v mono">cos +, sin −</span></div>
            <div class="g_note">Tan is sin/cos, so it inherits signs from both.</div>
          </div>
        </div>

        <div class="g_tableWrap g_box" data-tags="table sin cos tan values 0 30 45 60 90 special angles exact">
          <h4>Special angle values (SAT expects these fast)</h4>
          <table class="g_table">
            <thead>
              <tr><th>θ</th><th>rad</th><th>sin θ</th><th>cos θ</th><th>tan θ</th></tr>
            </thead>
            <tbody>
              <tr data-tags="0 0deg 0rad"><td>0°</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
              <tr data-tags="30 pi/6"><td>30°</td><td>π/6</td><td>1/2</td><td>√3/2</td><td>√3/3</td></tr>
              <tr data-tags="45 pi/4"><td>45°</td><td>π/4</td><td>√2/2</td><td>√2/2</td><td>1</td></tr>
              <tr data-tags="60 pi/3"><td>60°</td><td>π/3</td><td>√3/2</td><td>1/2</td><td>√3</td></tr>
              <tr data-tags="90 pi/2"><td>90°</td><td>π/2</td><td>1</td><td>0</td><td class="g_warn">undefined</td></tr>
            </tbody>
          </table>
          <div class="g_note"><strong>Precision:</strong> tan(90°) is <strong>undefined</strong>. Near 90°, tan grows without bound, but at 90° itself: undefined.</div>
        </div>
      </div>

      <div class="g_section" data-tags="formulas identities sohcahtoa pythagorean tan equals sin over cos sec csc cot">
        <h3>2) Formulas you keep using</h3>

        <div class="g_grid">
          <div class="g_box ok" data-tags="sohcahtoa right triangle opposite adjacent hypotenuse">
            <h4>SOH-CAH-TOA (right triangle only)</h4>
            <div class="g_line"><span class="g_k">sin θ =</span> <span class="g_v">opposite / hypotenuse</span></div>
            <div class="g_line"><span class="g_k">cos θ =</span> <span class="g_v">adjacent / hypotenuse</span></div>
            <div class="g_line"><span class="g_k">tan θ =</span> <span class="g_v">opposite / adjacent</span></div>
            <div class="g_note">Opposite/adjacent depend on where θ is sitting.</div>
          </div>

          <div class="g_box" data-tags="pythagorean identity sin^2 cos^2 equals 1">
            <h4>Pythagorean identity</h4>
            <div class="g_line mono"><span class="g_v">sin²θ + cos²θ = 1</span></div>
            <div class="g_note">SAT uses this to solve “missing trig value” problems.</div>
          </div>

          <div class="g_box" data-tags="tan identity tan equals sin over cos">
            <h4>Tan as a ratio of sin and cos</h4>
            <div class="g_line mono"><span class="g_v">tan θ = sin θ / cos θ</span></div>
            <div class="g_note">Fast when they hand you (cos, sin) on the unit circle.</div>
          </div>

          <div class="g_box" data-tags="reciprocal identities sec csc cot definitions">
            <h4>Reciprocals (show up sometimes)</h4>
            <div class="g_line mono"><span class="g_v">sec θ = 1 / cos θ</span></div>
            <div class="g_line mono"><span class="g_v">csc θ = 1 / sin θ</span></div>
            <div class="g_line mono"><span class="g_v">cot θ = 1 / tan θ = cos θ / sin θ</span></div>
          </div>
        </div>

        <div class="g_box bad" data-tags="undefined tan cos 0 division by zero">
          <h4>Undefined (SAT’s exact word)</h4>
          <div class="g_line"><span class="g_k">tan θ is undefined when:</span> <span class="g_v mono">cos θ = 0</span></div>
          <div class="g_line"><span class="g_k">Examples:</span> <span class="g_v mono">90°, 270° (π/2, 3π/2)</span></div>
          <div class="g_note">If the denominator is 0, you do not call it “infinite.” You call it “undefined.”</div>
        </div>
      </div>

      <div class="g_section" data-tags="radians arcs arc length sector area s=rθ 1/2 r^2 θ">
        <h3>3) Radians & arcs (human translation)</h3>

        <div class="g_grid">
          <div class="g_box ok" data-tags="radian definition arc length radius walk along circle">
            <h4>What a radian means</h4>
            <div class="g_line"><span class="g_k">Picture:</span> walk along the circle’s edge.</div>
            <div class="g_line"><span class="g_k">Count:</span> how many “radius-length steps” you walked.</div>
            <div class="g_line"><span class="g_k">That count is:</span> <span class="g_v">θ in radians</span></div>
            <div class="g_note">Radians measure angle using distance along the edge, scaled by radius.</div>
          </div>

          <div class="g_box" data-tags="arc length formula s=rθ theta radians">
            <h4>Arc length</h4>
            <div class="g_line mono"><span class="g_v">s = r · θ</span></div>
            <div class="g_note">θ must be in radians.</div>
          </div>

          <div class="g_box" data-tags="sector area formula 1/2 r^2 θ">
            <h4>Sector area (sometimes)</h4>
            <div class="g_line mono"><span class="g_v">A = ½ · r² · θ</span></div>
            <div class="g_note">θ must be in radians.</div>
          </div>

          <div class="g_box" data-tags="unit circle shortcut r=1 s=theta">
            <h4>Unit circle shortcut</h4>
            <div class="g_line"><span class="g_k">If r = 1:</span> <span class="g_v mono">s = θ</span></div>
            <div class="g_note">On the unit circle, radians literally equal arc length.</div>
          </div>
        </div>
      </div>

      <div class="g_section" data-tags="vocabulary reference angle opposite adjacent hypotenuse elevation depression">
        <h3>4) SAT words (what they really mean)</h3>

        <div class="g_grid">
          <div class="g_box" data-tags="opposite adjacent hypotenuse definitions">
            <h4>Opposite / Adjacent / Hypotenuse</h4>
            <div class="g_line"><span class="g_k">Hypotenuse:</span> <span class="g_v">longest side, across the right angle</span></div>
            <div class="g_line"><span class="g_k">Opposite:</span> <span class="g_v">across from θ</span></div>
            <div class="g_line"><span class="g_k">Adjacent:</span> <span class="g_v">touches θ (not the hypotenuse)</span></div>
          </div>

          <div class="g_box ok" data-tags="reference angle definition acute base angle to x-axis">
            <h4>Reference angle</h4>
            <div class="g_line"><span class="g_k">Meaning:</span> <span class="g_v">the small “base” angle to the x-axis</span></div>
            <div class="g_note">Magnitude comes from the reference angle. Sign comes from the quadrant.</div>
          </div>

          <div class="g_box" data-tags="angle of elevation depression parallel lines same angle">
            <h4>Elevation / depression</h4>
            <div class="g_line"><span class="g_k">Trick:</span> “elevation” and “depression” create the same acute angle (parallel lines).</div>
            <div class="g_note">SAT uses words to distract you. You keep the triangle.</div>
          </div>

          <div class="g_box bad" data-tags="trap sin+cos=1 wrong">
            <h4>Trap SAT loves</h4>
            <div class="g_line"><span class="g_k">Wrong:</span> <span class="g_v mono">sin θ + cos θ = 1</span></div>
            <div class="g_line"><span class="g_k">Right:</span> <span class="g_v mono">sin²θ + cos²θ = 1</span></div>
            <div class="g_note">Distance uses squares. The unit circle locks distance.</div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<script>
/* =========================================================
   SAT TRIG TEACHING ENGINE (v2.2)
   Workshop overhaul:
   - More intuitive language everywhere
   - Tan precision: undefined vs unbounded growth
   - Radians/Arcs re-built: “walk radius-lengths along the edge”
   - Word-problem scene fixed (ground + tan)
   + Must-memorize Glossary popup
   - G opens/closes glossary (disabled during quiz)
   ========================================================= */

const cvs = document.getElementById("cvs");
const ctx = cvs.getContext("2d", {alpha:false});

const colors = {
  bg:"#050505", grid:"#222",
  sin:"#ff0055", cos:"#00ccff", tan:"#ffcc00",
  white:"#fff", muted:"#888", ok:"#22c55e", bad:"#ef4444",
};

const SPECIAL_DEG = [0,30,45,60,90,120,135,150,180,210,225,240,270,300,315,330,360];
const TAU = 2*Math.PI;

const state = {
  w:0,h:0,
  baseCx:0, baseCy:0, baseR:220,
  theta: 0.65,
  dragging:false,
  readout:true,
  snap:false,
  lessonIndex:0,
  layerIndex:0,
  unlockedLayer:0,

  // quiz runtime
  quizActive:false,
  quizEndsAt:0,
  quizDurationMs:12000,
  quizTimer:null,
  uiLocked:false,
};

// lesson SAT-passed tracking
const progress = {}; // progress[lessonId] = { satPassed: true }

/* ---------- helpers ---------- */
function radToDeg(r){ return r*180/Math.PI; }
function degToRad(d){ return d*Math.PI/180; }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function normDeg(d){ let x=d%360; if(x<0) x+=360; if(Math.abs(x-360)<1e-9) x=0; return x; }
function quadrantFromDeg(d0){
  const d = normDeg(d0);
  if(d===0) return "Axis +x";
  if(d===90) return "Axis +y";
  if(d===180) return "Axis -x";
  if(d===270) return "Axis -y";
  if(d>0 && d<90) return "QI";
  if(d>90 && d<180) return "QII";
  if(d>180 && d<270) return "QIII";
  return "QIV";
}
function referenceAngleDeg(d0){
  const d = normDeg(d0);
  if(d>=0 && d<=90) return d;
  if(d>90 && d<180) return 180-d;
  if(d>=180 && d<=270) return d-180;
  if(d>270 && d<360) return 360-d;
  return 0;
}
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b,a%b]; } return a||1; }
function degToPiFrac(deg){
  const d = normDeg(deg);
  if(d===0) return "0";
  if(d===180) return "π";
  if(d===360) return "2π";
  let num = Math.round(d);
  let den = 180;
  const g = gcd(num, den);
  num/=g; den/=g;
  if(den===1) return `${num}π`;
  if(num===1) return `π/${den}`;
  return `${num}π/${den}`;
}
function nearestSpecialDeg(d0){
  const d = normDeg(d0);
  let best=SPECIAL_DEG[0], bestDist=1e9;
  for(const s of SPECIAL_DEG){
    const dist = Math.min(Math.abs(d-s), Math.abs((d+360)-s), Math.abs(d-(s+360)));
    if(dist<bestDist){ bestDist=dist; best=s; }
  }
  return {best, dist:bestDist};
}
function thetaSignedForArc(rad){
  let x = rad % TAU;
  if(x<=-Math.PI) x += TAU;
  if(x> Math.PI) x -= TAU;
  return x;
}
function fmt(x){
  if(!Number.isFinite(x)) return "undef";
  const ax=Math.abs(x);
  if(ax<1e-4) return "0";
  return x.toFixed(3);
}

/* Exact trig for special angles */
const EXACT_Q1 = {
  0:   {sin:"0",      cos:"1",      tan:"0"},
  30:  {sin:"1/2",    cos:"√3/2",   tan:"√3/3"},
  45:  {sin:"√2/2",   cos:"√2/2",   tan:"1"},
  60:  {sin:"√3/2",   cos:"1/2",    tan:"√3"},
  90:  {sin:"1",      cos:"0",      tan:"undef"},
};
function applySign(valStr, sign){
  if(valStr==="0") return "0";
  if(valStr==="undef") return "undef";
  if(sign>=0) return valStr;
  if(valStr.startsWith("-")) return valStr;
  return "-" + valStr;
}
function exactFromDeg(deg){
  const d = normDeg(deg);
  const ref = referenceAngleDeg(d);
  const quad = quadrantFromDeg(d);
  if(d===0)   return {sin:"0", cos:"1", tan:"0"};
  if(d===90)  return {sin:"1", cos:"0", tan:"undef"};
  if(d===180) return {sin:"0", cos:"-1", tan:"0"};
  if(d===270) return {sin:"-1", cos:"0", tan:"undef"};
  if(d===360) return {sin:"0", cos:"1", tan:"0"};

  const base = EXACT_Q1[ref];
  if(!base) return null;

  const sgn = {
    QI:  {sin:+1, cos:+1, tan:+1},
    QII: {sin:+1, cos:-1, tan:-1},
    QIII:{sin:-1, cos:-1, tan:+1},
    QIV: {sin:-1, cos:+1, tan:-1},
  }[quad];

  return {
    sin: applySign(base.sin, sgn.sin),
    cos: applySign(base.cos, sgn.cos),
    tan: (base.tan==="undef") ? "undef" : applySign(base.tan, sgn.tan)
  };
}

/* =========================================================
   Lessons (Workshop rewrite)
   ========================================================= */
const lessons = [
  {
    id:"unit",
    nav:"0 Unit Circle",
    title:"Trig is: angle → point",
    subtitle:"Drag the point. That’s trig. Everything else is just different ways of describing the same point.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:false, projections:false, labels:false, measureLine:false, quadrants:false},
        html:`
          <p><strong>What to do:</strong> drag the white point around the circle.</p>
          <div class="box">
            <p>Think of a steering wheel.</p>
            <ul>
              <li>θ tells you <strong>which direction</strong> you’re pointing.</li>
              <li>The point shows you <strong>where you land</strong> on the circle.</li>
            </ul>
            <p>No formulas yet. Just: turn → land.</p>
          </div>
          <p class="tag">If angle decides the point, trig stops being random.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false},
        html:`
          <p><strong>Now add meaning:</strong> that point has an address.</p>
          <div class="box ok">
            <p>Every point has two coordinates:</p>
            <ul>
              <li><strong>x</strong> = how far right/left</li>
              <li><strong>y</strong> = how far up/down</li>
            </ul>
            <p>On the stage, we draw those as two “drops” from the point:</p>
            <ul>
              <li><span style="color:var(--cos)"><strong>Blue</strong></span> is the x-value.</li>
              <li><span style="color:var(--sin)"><strong>Pink</strong></span> is the y-value.</li>
            </ul>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false},
        html:`
          <p><strong>Math translation (finally):</strong></p>
          <div class="box ok">
            <p class="mono"><strong>x = cos(θ)</strong> and <strong>y = sin(θ)</strong></p>
            <p>Cos is “how much x.” Sin is “how much y.”</p>
          </div>
          <div class="box">
            <p><strong>Why</strong> <span class="mono">sin² + cos² = 1</span>:</p>
            <p>The radius is locked to 1. The distance from the center never changes.</p>
            <p>Distance uses squares, so the circle forces:</p>
            <p class="mono"><strong>cos²(θ) + sin²(θ) = 1</strong></p>
          </div>
          <div class="box bad">
            <p><strong>SAT trap:</strong> “sin + cos = 1”.</p>
            <p>No. The circle locks distance, and distance uses squares.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false},
        html:`
          <div class="sat">
            <div class="q">How SAT hides this:</div>
            <div class="a">
              Point P is on the unit circle. If P is <span class="mono">(0.6, 0.8)</span>, what is <span class="mono">sin(θ)</span>?
            </div>
            <div class="map">
              <p><strong>Map:</strong> on the unit circle, <span class="mono">x = cos(θ)</span> and <span class="mono">y = sin(θ)</span>.</p>
              <p><strong>So:</strong> <span class="mono">sin(θ)</span> is just the y-value → <span class="mono">0.8</span>.</p>
              <p><strong>Quick check:</strong> 0.6² + 0.8² = 1. SAT loves this check.</p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"soh",
    nav:"1 SOHCAHTOA",
    title:"SOHCAHTOA is a labeling trick",
    subtitle:"Same triangle. Different names, depending on where θ is sitting.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:false, labels:false, measureLine:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <p><strong>Visual:</strong> look at the right triangle. Now look at θ.</p>
          <div class="box">
            <p>Three sides. Three roles:</p>
            <ul>
              <li><strong>Hypotenuse</strong>: the longest side (always)</li>
              <li><strong>Adjacent</strong>: the side touching θ (not the hypotenuse)</li>
              <li><strong>Opposite</strong>: the side directly across from θ</li>
            </ul>
          </div>
          <div class="box bad">
            <p><strong>Common mistake:</strong> students memorize “up = opposite.”</p>
            <p>Opposite depends on where θ is. Rotate θ, the roles swap.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <p><strong>Concept:</strong> trig ratios are “shape fingerprints.”</p>
          <div class="box ok">
            <p>Make the triangle bigger or smaller.</p>
            <p>All sides scale together.</p>
            <p>So the ratios stay the same. That’s why trig works.</p>
          </div>
          <p class="tag">Ratios ignore size. Ratios keep the angle’s DNA.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <p><strong>Math (but in plain English):</strong></p>
          <div class="box">
            <p class="mono"><strong>sin(θ)</strong> = opposite ÷ hypotenuse</p>
            <p class="mono"><strong>cos(θ)</strong> = adjacent ÷ hypotenuse</p>
            <p class="mono"><strong>tan(θ)</strong> = opposite ÷ adjacent</p>
          </div>
          <div class="box bad">
            <p><strong>How you actually choose:</strong> write “Have” and “Need.”</p>
            <p>Pick the ratio that uses what you have and outputs what you need.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <div class="sat">
            <div class="q">SAT version:</div>
            <div class="a">
              Opposite = 9 and hypotenuse = 15. What is <span class="mono">sin(θ)</span>?
            </div>
            <div class="map">
              <p><strong>Have:</strong> opposite and hypotenuse.</p>
              <p><strong>Need:</strong> sin.</p>
              <p><strong>Use:</strong> <span class="mono">sin = opp/hyp</span></p>
              <p><strong>Answer:</strong> <span class="mono">9/15 = 3/5</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"scale",
    nav:"2 Scaling",
    title:"Trig is a converter",
    subtitle:"Once θ is fixed, sin/cos/tan behave like conversion rates between lengths.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:false, measureLine:false, quadrants:false, scaleDemo:true, showOppAdjHyp:true},
        html:`
          <p><strong>Visual:</strong> same θ, different size triangle.</p>
          <div class="box">
            <p>The angle pins the shape.</p>
            <p>So you can scale the triangle up or down, but you can’t change its “look” unless θ changes.</p>
          </div>
          <p class="tag">Fix θ → ratios become multipliers.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, scaleDemo:true, showOppAdjHyp:true},
        html:`
          <p><strong>Concept:</strong> sin/cos/tan are the “percentage” of a side.</p>
          <div class="box ok">
            <p>If you know a long side, trig tells you the matching short side.</p>
            <p>If you know a short side, trig tells you the matching long side.</p>
            <p>Same θ means predictable conversions.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, scaleDemo:true, showOppAdjHyp:true},
        html:`
          <p><strong>Math patterns SAT repeats:</strong></p>
          <div class="box">
            <p class="mono">opposite = hypotenuse · sin(θ)</p>
            <p class="mono">adjacent = hypotenuse · cos(θ)</p>
            <p class="mono">opposite = adjacent · tan(θ)</p>
          </div>
          <div class="box bad">
            <p><strong>Speed rule:</strong> match the formula to the side you actually have.</p>
            <p>If you have the hypotenuse, sin/cos are usually the clean path.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, scaleDemo:true, showOppAdjHyp:true},
        html:`
          <div class="sat">
            <div class="q">SAT version:</div>
            <div class="a">
              Hypotenuse = 10 and <span class="mono">sin(θ)=0.6</span>. Find opposite.
            </div>
            <div class="map">
              <p><strong>Meaning:</strong> sin is the “opposite fraction of the hypotenuse.”</p>
              <p><strong>Compute:</strong> opposite = 10 · 0.6 = <span class="mono">6</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"special",
    nav:"3 Special Angles",
    title:"Special angles = SAT’s speed gate",
    subtitle:"Turn SNAP on. These are the only exact values SAT expects you to know instantly.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:false, measureLine:false, quadrants:false, specialMode:true},
        html:`
          <p><strong>Visual:</strong> turn <strong>SNAP</strong> on and drag.</p>
          <div class="box">
            <p>SAT cares about a small set of angles because their triangles are clean.</p>
            <p>Those clean triangles generate exact radicals instead of ugly decimals.</p>
          </div>
          <p class="tag">Exact values buy you time. Decimals steal it.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, specialMode:true},
        html:`
          <p><strong>Concept:</strong> it’s really just two triangles.</p>
          <div class="box ok">
            <p><strong>30–60–90</strong> ratios: <span class="mono">1 : √3 : 2</span></p>
            <p><strong>45–45–90</strong> ratios: <span class="mono">1 : 1 : √2</span></p>
            <p>Unit circle means radius = 1, so these ratios become the exact sin/cos values.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, specialMode:true},
        html:`
          <p><strong>Math (Quadrant I anchors):</strong></p>
          <div class="box">
            <p class="mono">sin 30 = 1/2,   cos 30 = √3/2</p>
            <p class="mono">sin 45 = √2/2,  cos 45 = √2/2</p>
            <p class="mono">sin 60 = √3/2,  cos 60 = 1/2</p>
          </div>
          <div class="box bad">
            <p><strong>Discipline:</strong> keep answers exact. Don’t decimalize √ unless SAT forces you.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, specialMode:true},
        html:`
          <div class="sat">
            <div class="q">SAT version:</div>
            <div class="a">
              What is <span class="mono">sin(π/3)</span>?
            </div>
            <div class="map">
              <p><strong>Convert:</strong> <span class="mono">π/3 = 60°</span></p>
              <p><strong>Recall:</strong> <span class="mono">sin 60 = √3/2</span></p>
              <p><strong>Answer:</strong> <span class="mono">√3/2</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"quadrants",
    nav:"4 Quadrants",
    title:"Same reference angle. Different signs.",
    subtitle:"Magnitude comes from Quadrant I. Signs come from left/right and up/down.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:false, measureLine:false, quadrants:true},
        html:`
          <p><strong>Visual:</strong> drag into all 4 quadrants.</p>
          <div class="box">
            <p>Don’t memorize “mystical sign rules.” Just look:</p>
            <ul>
              <li>Left side → x is negative → <strong>cos is negative</strong></li>
              <li>Down side → y is negative → <strong>sin is negative</strong></li>
            </ul>
            <p>Tan is sin ÷ cos, so it inherits signs from both.</p>
          </div>
          <p class="tag">Signs are geography. Not memorization.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:true},
        html:`
          <p><strong>Concept:</strong> reference angle is your “clean twin.”</p>
          <div class="box ok">
            <p>Step 1: find the acute angle to the x-axis (the reference angle).</p>
            <p>Step 2: grab the exact value as if you were in Quadrant I.</p>
            <p>Step 3: flip the sign based on where the point lives.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:true},
        html:`
          <p><strong>Math sign table (sin, cos, tan):</strong></p>
          <div class="box">
            <p class="mono">QI:  +  +  +</p>
            <p class="mono">QII: +  −  −</p>
            <p class="mono">QIII:−  −  +</p>
            <p class="mono">QIV: −  +  −</p>
          </div>
          <div class="box bad">
            <p><strong>Scoring reality:</strong> correct magnitude with wrong sign = wrong answer.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:true},
        html:`
          <div class="sat">
            <div class="q">SAT version:</div>
            <div class="a">
              If θ = 210°, what is <span class="mono">cos(θ)</span>?
            </div>
            <div class="map">
              <p><strong>ref:</strong> 210° → 30°</p>
              <p><strong>magnitude:</strong> cos 30 = √3/2</p>
              <p><strong>sign:</strong> 210° is QIII → cos is negative</p>
              <p><strong>answer:</strong> <span class="mono">−√3/2</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"tan",
    nav:"5 Tan",
    title:"Tan is “how steep”",
    subtitle:"We measure steepness by seeing where the direction-line hits a vertical measuring line.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:false, measureLine:true, quadrants:false},
        html:`
          <p><strong>Visual:</strong> the yellow line is your direction.</p>
          <div class="box">
            <p>Now we add a simple measuring tool:</p>
            <p><strong>a vertical measuring line at x = 1</strong> (the right edge of the unit circle).</p>
            <p>Extend your direction-line until it hits that measuring line.</p>
            <p>The height it hits is <strong>tan(θ)</strong>.</p>
          </div>
          <p class="tag">Tan is a height reading on a fixed measuring line.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:true, quadrants:false},
        html:`
          <p><strong>Concept:</strong> slope = “rise per 1 step.”</p>
          <div class="box ok">
            <p>If you move 1 unit to the right, how much do you rise (or fall) on that line?</p>
            <p>That “rise” is the slope.</p>
            <p>And tan(θ) is exactly that slope number.</p>
          </div>
          <div class="box">
            <p><strong>Important detail:</strong> sometimes the direction points left (Quadrant II/III).</p>
            <p>We still measure tan by extending the line both ways until it hits x = 1.</p>
            <p>Same line. Same steepness. Same tan.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:true, quadrants:false},
        html:`
          <p><strong>Math, connected to the picture:</strong></p>
          <div class="box">
            <p class="mono"><strong>tan(θ) = opposite / adjacent</strong></p>
            <p class="mono"><strong>tan(θ) = sin(θ) / cos(θ)</strong></p>
          </div>
          <div class="box bad">
            <p><strong>Precision:</strong> tan is <strong>undefined</strong> when cos = 0.</p>
            <p>That happens at 90° and 270°.</p>
            <p>Near 90°, tan becomes extremely large in magnitude (it grows without bound), but at 90° itself: undefined.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:true, quadrants:false},
        html:`
          <div class="sat">
            <div class="q">SAT version:</div>
            <div class="a">
              A line makes angle θ with the positive x-axis. If the slope is 3, what is <span class="mono">tan(θ)</span>?
            </div>
            <div class="map">
              <p><strong>Map:</strong> tan(θ) = slope</p>
              <p><strong>Answer:</strong> <span class="mono">3</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"co",
    nav:"6 Co-functions",
    title:"Sin and cos are the same leg… from different seats",
    subtitle:"If you swap the angle you’re looking from, “opposite” and “adjacent” swap too.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:false, measureLine:false, quadrants:false, coMode:true},
        html:`
          <p><strong>Visual:</strong> one triangle, two viewpoints.</p>
          <div class="box">
            <p>In a right triangle, the two sharp angles always add to 90°.</p>
            <p>If you switch which angle you call θ, the “across” side and the “touching” side swap roles.</p>
          </div>
          <p class="tag">Same triangle. The labels changed. That’s it.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, coMode:true},
        html:`
          <p><strong>Concept:</strong> complementary angles trade sin and cos.</p>
          <div class="box ok">
            <p>If an angle turns into (90° − θ), what was “vertical” becomes “horizontal” for that new angle.</p>
            <p>So sin and cos switch jobs.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, coMode:true},
        html:`
          <p><strong>Math (clean identities):</strong></p>
          <div class="box">
            <p class="mono">sin(θ) = cos(90° − θ)</p>
            <p class="mono">cos(θ) = sin(90° − θ)</p>
          </div>
          <div class="box bad">
            <p><strong>SAT trap:</strong> they write cos(90−θ) and hope you freeze.</p>
            <p>Don’t. It’s just sin(θ).</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, coMode:true},
        html:`
          <div class="sat">
            <div class="q">SAT version:</div>
            <div class="a">
              If <span class="mono">sin(x)=3/5</span> and x is acute, what is <span class="mono">cos(90°−x)</span>?
            </div>
            <div class="map">
              <p><strong>Identity:</strong> <span class="mono">cos(90°−x)=sin(x)</span></p>
              <p><strong>Answer:</strong> <span class="mono">3/5</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"word",
    nav:"7 Word Problems",
    title:"Word problems are just triangles wearing costumes",
    subtitle:"Height, ladder, shadow, drone, building… it’s still Opp/Adj/Hyp.",
    layers:[
      { flags:{scene:"word", circle:false, triangle:true, projections:true, labels:false, measureLine:false, quadrants:false, wordScene:true},
        html:`
          <p><strong>Visual:</strong> ground, wall, and a line-of-sight.</p>
          <div class="box">
            <p>Nothing new happened. Only the nouns changed.</p>
            <p>Your job is to translate nouns into triangle sides.</p>
          </div>
          <p class="tag">Translate first. Compute second.</p>
        `
      },
      { flags:{scene:"word", circle:false, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, wordScene:true},
        html:`
          <p><strong>Concept mapping (SAT translation):</strong></p>
          <div class="box ok">
            <ul>
              <li><strong>Height</strong> → opposite (usually)</li>
              <li><strong>Ground distance</strong> → adjacent (usually)</li>
              <li><strong>Ladder / cable / line of sight</strong> → hypotenuse (usually)</li>
            </ul>
          </div>
          <div class="box bad">
            <p><strong>Angle of depression / elevation:</strong> it’s the same angle (parallel lines).</p>
            <p>SAT uses words to create panic. Ignore the panic, keep the triangle.</p>
          </div>
        `
      },
      { flags:{scene:"word", circle:false, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, wordScene:true},
        html:`
          <p><strong>Math patterns that keep showing up:</strong></p>
          <div class="box">
            <p class="mono">height = ground · tan(θ)</p>
            <p class="mono">height = hypotenuse · sin(θ)</p>
            <p class="mono">ground = hypotenuse · cos(θ)</p>
          </div>
          <p>You choose based on what the problem gives you.</p>
        `
      },
      { flags:{scene:"word", circle:false, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, wordScene:true},
        html:`
          <div class="sat">
            <div class="q">SAT version:</div>
            <div class="a">
              From a point 80 m from a building, the angle of elevation is 28°. Approximately how tall is the building?
            </div>
            <div class="map">
              <p><strong>Translate:</strong> adjacent = 80, opposite = height</p>
              <p><strong>Use:</strong> <span class="mono">tan = opp/adj</span></p>
              <p><strong>Build:</strong> <span class="mono">height = 80·tan(28°)</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"rad",
    nav:"8 Radians",
    title:"Radians are ‘how far you walked’ along the circle",
    subtitle:"Degrees count slices. Radians count distance along the edge, measured in radius-lengths.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:false, projections:false, labels:false, measureLine:false, quadrants:false, arcMode:true},
        html:`
          <p><strong>Visual:</strong> notice two arcs:</p>
          <div class="box">
            <ul>
              <li><span style="color:var(--ok)"><strong>Green</strong></span> arc = <strong>1 radian</strong> (a fixed reference)</li>
              <li><span style="color:var(--vio)"><strong>Purple</strong></span> arc = your current θ</li>
            </ul>
            <p>A radian is an angle defined by <strong>arc length</strong>.</p>
            <p>1 radian means: the arc you cut off is exactly <strong>one radius long</strong>.</p>
          </div>
          <p class="tag">Radians aren’t “hard.” They’re a distance-based angle.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, arcMode:true},
        html:`
          <p><strong>Concept:</strong> count radius-lengths along the edge.</p>
          <div class="box ok">
            <p>Imagine walking along the circle’s edge starting at 0°.</p>
            <p>Ask: “How many radius-lengths have I walked?”</p>
            <p>That number is θ in radians.</p>
          </div>
          <div class="box">
            <p><strong>Unit circle shortcut:</strong> radius = 1, so the number of radius-lengths equals the arc length number.</p>
            <p>That’s why radians are the natural unit for circles.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, arcMode:true},
        html:`
          <p><strong>Math (connected to what you saw):</strong></p>
          <div class="box">
            <p class="mono"><strong>arc length</strong>: s = r·θ</p>
            <p class="mono">so θ = s/r</p>
          </div>
          <div class="box ok">
            <p><strong>Unit circle:</strong> r = 1 → <span class="mono">s = θ</span></p>
            <p>That’s literally “radians = arc length” on the unit circle.</p>
          </div>
          <div class="box">
            <p><strong>Two anchor facts:</strong></p>
            <p class="mono">π radians = 180°</p>
            <p class="mono">2π radians = 360°</p>
          </div>
          <div class="box bad">
            <p><strong>SAT precision:</strong> formulas like <span class="mono">s=rθ</span> and <span class="mono">A=(1/2)r²θ</span> require θ in radians.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, measureLine:false, quadrants:false, arcMode:true},
        html:`
          <div class="sat">
            <div class="q">SAT version:</div>
            <div class="a">
              A circle has radius 6. A sector has central angle <span class="mono">π/3</span>. What is the arc length?
            </div>
            <div class="map">
              <p><strong>Use:</strong> <span class="mono">s = rθ</span> (θ already in radians)</p>
              <p><strong>Compute:</strong> <span class="mono">s = 6·(π/3) = 2π</span></p>
            </div>
          </div>
        `
      }
    ]
  }
];

/* =========================================================
   Micro-quiz bank (fired on SAT layer)
   ========================================================= */
const quizBank = {
  unit: {
    q: "Point P is on the unit circle: P = (1/2, √3/2). What is θ (in standard position)?",
    choices: ["30°", "60°", "120°", "300°"],
    correct: 1
  },
  soh: {
    q: "Right triangle: Opp = 8 and Hyp = 10. What is sin(θ)?",
    choices: ["4/5", "5/4", "3/5", "8/10 (not simplified)"],
    correct: 0
  },
  scale: {
    q: "Adj = 12 and tan(θ) = 3/4. What is Opp?",
    choices: ["9", "16", "4", "3"],
    correct: 0
  },
  special: {
    q: "What is sin(π/4)?",
    choices: ["1/2", "√2/2", "√3/2", "1"],
    correct: 1
  },
  quadrants: {
    q: "θ = 150°. What is sin(θ)?",
    choices: ["-1/2", "1/2", "-√3/2", "√3/2"],
    correct: 1
  },
  tan: {
    q: "A line makes angle θ with +x axis. If slope = -2, what is tan(θ)?",
    choices: ["2", "-2", "1/2", "-1/2"],
    correct: 1
  },
  co: {
    q: "If sin(x) = 3/5 and x is acute, what is cos(90° - x)?",
    choices: ["4/5", "3/5", "5/3", "1/5"],
    correct: 1
  },
  word: {
    q: "Ground = 20 and height = 20·tan(θ). Which ratio did you use?",
    choices: ["sin = Opp/Hyp", "cos = Adj/Hyp", "tan = Opp/Adj", "cot = Adj/Opp"],
    correct: 2
  },
  rad: {
    q: "Radius r = 5, θ = 2π/5 (radians). What is arc length s?",
    choices: ["2π", "π/2", "10π", "5π/2"],
    correct: 0
  },
};

/* =========================================================
   UI wiring
   ========================================================= */
const nav = document.getElementById("nav");

function buildNav(){
  nav.innerHTML = "";
  lessons.forEach((L, i) => {
    const b = document.createElement("button");
    b.textContent = L.nav;
    b.onclick = () => setLesson(i);
    b.id = `nav_${i}`;
    nav.appendChild(b);
  });
}
function ensureProgress(lessonId){
  if(!progress[lessonId]) progress[lessonId] = { satPassed:false };
  return progress[lessonId];
}
function setLesson(i){
  state.lessonIndex = i;
  state.layerIndex = 0;
  state.unlockedLayer = 0;

  stopQuiz(); // hard stop on lesson change
  closeGlossary(); // close glossary if open
  updatePanel(); updateNav(); draw(); updateHud();
}
function setLayer(k){
  if(state.uiLocked) return;
  if(k > state.unlockedLayer) return;

  state.layerIndex = k;

  const lesson = lessons[state.lessonIndex];
  const prog = ensureProgress(lesson.id);
  if(state.layerIndex === 3 && !prog.satPassed){
    updatePanel(); draw(); updateHud();
    startQuizForLesson(lesson.id);
    return;
  }

  updatePanel(); draw(); updateHud();
}
function nextLayer(){
  if(state.uiLocked) return;
  if(state.layerIndex < 3){
    state.unlockedLayer = Math.max(state.unlockedLayer, state.layerIndex + 1);
    state.layerIndex++;

    const lesson = lessons[state.lessonIndex];
    const prog = ensureProgress(lesson.id);
    if(state.layerIndex === 3 && !prog.satPassed){
      updatePanel(); draw(); updateHud();
      startQuizForLesson(lesson.id);
      return;
    }

    updatePanel(); draw(); updateHud();
  }
}
function prevLayer(){
  if(state.uiLocked) return;
  if(state.layerIndex > 0){
    state.layerIndex--;
    updatePanel(); draw(); updateHud();
  }
}
function nextLesson(){ if(state.uiLocked) return; if(state.lessonIndex < lessons.length-1) setLesson(state.lessonIndex+1); }
function prevLesson(){ if(state.uiLocked) return; if(state.lessonIndex > 0) setLesson(state.lessonIndex-1); }
function updateNav(){
  lessons.forEach((_, i) => {
    const b = document.getElementById(`nav_${i}`);
    if(b) b.classList.toggle("active", i === state.lessonIndex);
  });
}
function updatePanel(){
  const L = lessons[state.lessonIndex];
  const layer = L.layers[state.layerIndex];

  document.getElementById("title").textContent = L.title;
  document.getElementById("subtitle").textContent = L.subtitle;
  document.getElementById("body").innerHTML = layer.html;

  for(let k=0;k<4;k++){
    const btn = document.getElementById(`layer${k}`);
    btn.classList.toggle("active", k === state.layerIndex);
    const locked = k > state.unlockedLayer;
    btn.classList.toggle("locked", locked);
    btn.disabled = locked || state.uiLocked;
  }

  document.getElementById("btnBackLayer").disabled = state.layerIndex === 0 || state.uiLocked;
  document.getElementById("btnForwardLayer").disabled = state.layerIndex === 3 || state.uiLocked;
  document.getElementById("btnPrev").disabled = state.lessonIndex === 0 || state.uiLocked;
  document.getElementById("btnNext").disabled = state.lessonIndex === lessons.length-1 || state.uiLocked;
}

window.setLayer = setLayer;
window.nextLayer = nextLayer;
window.prevLayer = prevLayer;
window.nextLesson = nextLesson;
window.prevLesson = prevLesson;

/* =========================================================
   Controls
   ========================================================= */
const btnReadout = document.getElementById("btnReadout");
const btnSnap = document.getElementById("btnSnap");
const btnGlossary = document.getElementById("btnGlossary");

btnReadout.addEventListener("click", () => {
  if(state.uiLocked) return;
  state.readout = !state.readout;
  btnReadout.classList.toggle("active", state.readout);
  draw();
});
btnSnap.addEventListener("click", () => {
  if(state.uiLocked) return;
  state.snap = !state.snap;
  btnSnap.classList.toggle("active", state.snap);
  draw(); updateHud();
});

/* =========================================================
   Glossary popup (G)
   ========================================================= */
const glossaryModal = document.getElementById("glossaryModal");
const gBackdrop = document.getElementById("g_backdrop");
const gCloseBtn = document.getElementById("g_closeBtn");
const gSearchInput = document.getElementById("g_searchInput");
const gBody = document.getElementById("g_body");

function openGlossary(){
  if(state.uiLocked) return; // no glossary during quiz lock
  glossaryModal.classList.add("active");
  glossaryModal.setAttribute("aria-hidden","false");
  setTimeout(() => gSearchInput.focus(), 0);
}
function closeGlossary(){
  glossaryModal.classList.remove("active");
  glossaryModal.setAttribute("aria-hidden","true");
  if(gSearchInput) gSearchInput.value = "";
  filterGlossary("");
}
function toggleGlossary(){
  if(state.uiLocked) return;
  const open = glossaryModal.classList.contains("active");
  if(open) closeGlossary(); else openGlossary();
}
function filterGlossary(q){
  const query = (q || "").trim().toLowerCase();
  const blocks = gBody.querySelectorAll("[data-tags]");
  blocks.forEach(el => {
    const tags = (el.getAttribute("data-tags") || "").toLowerCase();
    const text = (el.innerText || "").toLowerCase();
    const hit = !query || tags.includes(query) || text.includes(query);
    el.style.display = hit ? "" : "none";
  });
}

btnGlossary.addEventListener("click", () => openGlossary());
gBackdrop.addEventListener("click", () => closeGlossary());
gCloseBtn.addEventListener("click", () => closeGlossary());
gSearchInput.addEventListener("input", (e) => filterGlossary(e.target.value));

window.addEventListener("keydown", (e) => {
  const k = (e.key || "").toLowerCase();
  if(k === "g"){
    // ignore if typing in an input outside glossary? (safe: still toggles)
    toggleGlossary();
  }
  if(k === "escape" && glossaryModal.classList.contains("active")){
    closeGlossary();
  }
});

/* =========================================================
   Quiz system
   ========================================================= */
const quizOverlay = document.getElementById("quizOverlay");
const quizQ = document.getElementById("quizQ");
const quizChoices = document.getElementById("quizChoices");
const quizResult = document.getElementById("quizResult");
const quizBar = document.getElementById("quizBar");
const quizTime = document.getElementById("quizTime");

function lockUI(on){
  state.uiLocked = on;
  if(on) closeGlossary(); // never overlap
  document.querySelectorAll("#nav button").forEach(b => b.disabled = on);
  document.querySelectorAll("#layers button").forEach(b => b.disabled = on || b.classList.contains("locked"));
  btnReadout.disabled = on;
  btnSnap.disabled = on;
  btnGlossary.disabled = on;
  updatePanel();
}
function startQuizForLesson(lessonId){
  const item = quizBank[lessonId];
  if(!item){
    ensureProgress(lessonId).satPassed = true;
    return;
  }

  stopQuiz();
  state.quizActive = true;
  lockUI(true);

  quizOverlay.classList.add("active");
  quizResult.textContent = "";
  quizResult.className = "";
  quizQ.textContent = item.q;

  quizChoices.innerHTML = "";
  item.choices.forEach((c, idx) => {
    const b = document.createElement("button");
    b.className = "choice";
    b.innerHTML = `<span class="mono">${String.fromCharCode(65+idx)})</span> ${c}`;
    b.onclick = () => resolveQuiz(idx);
    quizChoices.appendChild(b);
  });

  state.quizEndsAt = Date.now() + state.quizDurationMs;

  state.quizTimer = setInterval(() => {
    const now = Date.now();
    const left = state.quizEndsAt - now;
    const frac = clamp(left / state.quizDurationMs, 0, 1);

    quizBar.style.width = `${(frac*100).toFixed(1)}%`;
    quizBar.style.background = frac > 0.33 ? "rgba(34,197,94,0.85)" : "rgba(239,68,68,0.85)";
    quizTime.textContent = `${(left/1000).toFixed(1)}s`;

    if(left <= 0){
      failQuiz("Time.");
    }
  }, 80);
}
function resolveQuiz(choiceIdx){
  if(!state.quizActive) return;
  const lessonId = lessons[state.lessonIndex].id;
  const item = quizBank[lessonId];
  if(!item) return;

  quizChoices.querySelectorAll("button").forEach(b => b.disabled = true);

  if(choiceIdx === item.correct){
    passQuiz();
  } else {
    failQuiz("Wrong.");
  }
}
function passQuiz(){
  if(!state.quizActive) return;
  const lessonId = lessons[state.lessonIndex].id;
  ensureProgress(lessonId).satPassed = true;

  quizResult.textContent = "Correct. SAT layer unlocked.";
  quizResult.className = "good";

  setTimeout(() => {
    stopQuiz();
    state.unlockedLayer = Math.max(state.unlockedLayer, 3);
    updatePanel(); draw(); updateHud();
  }, 650);
}
function failQuiz(reason){
  if(!state.quizActive) return;

  quizResult.textContent = `${reason} Drop one step.`;
  quizResult.className = "bad";

  setTimeout(() => {
    stopQuiz();
    state.layerIndex = Math.max(0, state.layerIndex - 1);
    state.unlockedLayer = Math.min(state.unlockedLayer, 2);
    updatePanel(); draw(); updateHud();
  }, 850);
}
function stopQuiz(){
  if(state.quizTimer){
    clearInterval(state.quizTimer);
    state.quizTimer = null;
  }
  state.quizActive = false;
  quizOverlay.classList.remove("active");
  lockUI(false);

  quizBar.style.width = "100%";
  quizBar.style.background = "rgba(34,197,94,0.85)";
  quizTime.textContent = `${(state.quizDurationMs/1000).toFixed(1)}s`;
}

/* =========================================================
   Scene geometry
   ========================================================= */
function currentFlags(){
  return lessons[state.lessonIndex].layers[state.layerIndex].flags;
}
function getSceneAnchor(flags){
  if(flags.scene !== "word"){
    return {ox: state.baseCx, oy: state.baseCy, R: state.baseR};
  }
  const ox = state.w*0.22;
  const oy = state.h*0.78;
  const R  = Math.min(state.w, state.h)*0.30;
  return {ox, oy, R};
}

/* =========================================================
   Input
   ========================================================= */
function interact(px, py){
  if(state.uiLocked) return;

  const flags = currentFlags();
  const {ox, oy} = getSceneAnchor(flags);

  const dx = px - ox;
  const dy = py - oy;
  let ang = Math.atan2(-dy, dx);

  if(flags.scene === "word"){
    ang = clamp(ang, degToRad(5), degToRad(80));
  }

  state.theta = ang;

  if(state.snap){
    const d = normDeg(radToDeg(state.theta));
    const {best, dist} = nearestSpecialDeg(d);
    if(dist < 1.8) state.theta = degToRad(best);
  }

  draw(); updateHud();
}
cvs.addEventListener("mousedown", e => { state.dragging = true; interact(e.offsetX, e.offsetY); });
window.addEventListener("mousemove", e => {
  if(!state.dragging) return;
  const r = cvs.getBoundingClientRect();
  interact(e.clientX - r.left, e.clientY - r.top);
});
window.addEventListener("mouseup", () => state.dragging=false);

cvs.addEventListener("touchstart", e => {
  e.preventDefault();
  state.dragging = true;
  const r = cvs.getBoundingClientRect();
  interact(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
}, {passive:false});
cvs.addEventListener("touchmove", e => {
  e.preventDefault();
  if(!state.dragging) return;
  const r = cvs.getBoundingClientRect();
  interact(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
}, {passive:false});
cvs.addEventListener("touchend", () => state.dragging=false);

/* =========================================================
   Resize
   ========================================================= */
function resize(){
  const p = cvs.parentElement;
  state.w = p.clientWidth;
  state.h = p.clientHeight;
  cvs.width = state.w;
  cvs.height = state.h;

  state.baseCx = state.w * 0.38;
  state.baseCy = state.h * 0.64;
  state.baseR  = Math.min(state.w, state.h) * 0.30;

  draw(); updateHud();
}
window.addEventListener("resize", resize);

/* =========================================================
   HUD
   ========================================================= */
function effectiveTheta(flags){
  if(flags.scene === "word"){
    return clamp(state.theta, degToRad(5), degToRad(80));
  }
  return state.theta;
}
function updateHud(){
  const flags = currentFlags();
  const th = effectiveTheta(flags);

  const rawDeg = radToDeg(th);
  const eqDeg = normDeg(rawDeg);
  const ref = referenceAngleDeg(eqDeg);
  const quad = quadrantFromDeg(eqDeg);

  const piForm = degToPiFrac(eqDeg);
  document.getElementById("hudTheta").textContent = `θ = ${rawDeg.toFixed(0)}° (${piForm})`;
  document.getElementById("hudEq").textContent = `Equivalent: ${eqDeg.toFixed(0)}°`;
  document.getElementById("hudQuad").textContent = quad;
  document.getElementById("hudRef").textContent = `ref ${ref.toFixed(0)}° (${degToPiFrac(ref)})`;

  const qPill = document.getElementById("hudQuad");
  qPill.classList.remove("ok","bad");
  qPill.classList.add(quad.startsWith("Axis") ? "bad" : "ok");
}

/* =========================================================
   Drawing engine
   ========================================================= */
function draw(){
  if(state.w === 0 || state.h === 0) return;

  const flags = currentFlags();
  const {ox, oy, R} = getSceneAnchor(flags);
  const th = effectiveTheta(flags);

  ctx.fillStyle = colors.bg;
  ctx.fillRect(0,0,state.w,state.h);

  if(flags.scene === "word"){
    drawWordScene(ox, oy, R, th, flags);
    return;
  }

  drawAxes(ox, oy);

  if(flags.quadrants) {
    shadeQuadrants(ox, oy, R);
    drawQuadrantLabels(ox, oy, R);
  }

  if(flags.circle) drawCircle(ox, oy, R);

  const px = ox + R * Math.cos(th);
  const py = oy - R * Math.sin(th);

  if(flags.triangle) drawTriangle(ox, oy, px, py, R, th, flags);
  else drawRadius(ox, oy, px, py, R, th, flags);

  if(flags.measureLine) drawTanMeasuringLine(ox, oy, R, th);

  if(flags.arcMode){
    drawArcToolkit(ox, oy, R, th); // includes 1 rad reference arc + theta arc
  }

  if(state.readout) drawMicroReadout(ox, oy, px, py, th, flags);
}

/* ---------- primitives ---------- */
function drawAxes(cx, cy){
  ctx.strokeStyle = colors.grid;
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(state.w, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, state.h); ctx.stroke();
}
function drawCircle(cx, cy, R){
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(cx, cy, R, 0, TAU); ctx.stroke();
}
function shadeQuadrants(cx, cy, R){
  ctx.save();
  ctx.beginPath(); ctx.arc(cx,cy,R,0,TAU); ctx.clip();
  ctx.globalAlpha = 0.10;
  ctx.fillStyle = colors.ok;  ctx.fillRect(cx, cy-R, R, R);     // QI
  ctx.fillStyle = colors.cos; ctx.fillRect(cx-R, cy-R, R, R);   // QII
  ctx.fillStyle = colors.sin; ctx.fillRect(cx-R, cy, R, R);     // QIII
  ctx.fillStyle = colors.tan; ctx.fillRect(cx, cy, R, R);       // QIV
  ctx.restore();
}
function drawQuadrantLabels(cx, cy, R){
  const spots = [
    {t:"QI",  x: cx+R*0.45, y: cy-R*0.45},
    {t:"QII", x: cx-R*0.45, y: cy-R*0.45},
    {t:"QIII",x: cx-R*0.45, y: cy+R*0.45},
    {t:"QIV", x: cx+R*0.45, y: cy+R*0.45},
  ];
  ctx.save();
  ctx.font = "1000 14px Segoe UI, system-ui, sans-serif";
  ctx.textAlign="center"; ctx.textBaseline="middle";
  for(const s of spots){
    ctx.fillStyle = "rgba(255,255,255,0.12)";
    ctx.fillText(s.t, s.x, s.y);
  }
  ctx.restore();
}
function neon(x1,y1,x2,y2,color,width=3){
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
  ctx.lineWidth = width*4;
  ctx.strokeStyle = color;
  ctx.globalAlpha = 0.22;
  ctx.stroke();
  ctx.lineWidth = width;
  ctx.globalAlpha = 1;
  ctx.strokeStyle = color;
  ctx.stroke();
}
function dashed(x1,y1,x2,y2,color){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.setLineDash([6,6]);
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}
function dot(x,y,r,color){
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
}
function label(x,y,text,color){
  ctx.save();
  ctx.font = "980 12px Segoe UI, system-ui, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  const pad=6;
  const w = ctx.measureText(text).width + pad*2;
  ctx.fillStyle = "rgba(0,0,0,0.72)";
  ctx.fillRect(x-w/2, y-10, w, 20);
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.strokeRect(x-w/2, y-10, w, 20);
  ctx.fillStyle = color;
  ctx.fillText(text, x, y);
  ctx.restore();
}
function rightAngle(x,y,size){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.55)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x - size, y);
  ctx.lineTo(x - size, y - size);
  ctx.lineTo(x, y - size);
  ctx.stroke();
  ctx.restore();
}
function laser(x1,y1,x2,y2){
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(255,255,255,0.9)";
  ctx.setLineDash([6,6]);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.lineWidth = 10;
  ctx.strokeStyle = "rgba(255,255,255,0.14)";
  ctx.stroke();
  ctx.restore();
  dot(x2,y2,4,"#fff");
}
function angleArc(cx, cy, theta, r){
  // visual hint of the angle at the center
  const t = thetaSignedForArc(theta);
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.65)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  // canvas angles go clockwise because y grows downward; use -t for end
  ctx.arc(cx, cy, r, 0, -t, t<0);
  ctx.stroke();
  ctx.restore();
}

/* ---------- scene drawing ---------- */
function drawRadius(cx, cy, px, py, R, theta){
  neon(cx, cy, px, py, colors.white, 3);
  dot(px, py, 6, "#fff");
  angleArc(cx, cy, theta, R*0.18);
}
function drawTriangle(cx, cy, px, py, R, theta, flags){
  neon(cx, cy, px, cy, colors.cos, flags.showOppAdjHyp ? 4 : 3);
  neon(px, cy, px, py, colors.sin, flags.showOppAdjHyp ? 4 : 3);
  neon(cx, cy, px, py, colors.white, flags.showOppAdjHyp ? 4 : 3);

  dot(px, py, 6, "#fff");
  angleArc(cx, cy, theta, R*0.16);

  if(flags.projections){
    dashed(px, py, px, cy, "rgba(0,204,255,0.45)");
    dashed(px, py, cx, py, "rgba(255,0,85,0.45)");
  }

  if(flags.labels){
    if(flags.showOppAdjHyp){
      label((cx+px)/2, cy+18, "Adjacent", colors.cos);
      label(px+48, (cy+py)/2, "Opposite", colors.sin);
      label((cx+px)/2+12, (cy+py)/2-12, "Hypotenuse", "#fff");
    } else {
      label((cx+px)/2, cy+18, "x = cos(θ)", colors.cos);
      label(cx-52, (cy+py)/2, "y = sin(θ)", colors.sin);
      label((cx+px)/2+10, (cy+py)/2-12, "radius", "#fff");
    }
  }

  rightAngle(px, cy, 14);

  if(flags.scaleDemo){
    const scale = 1.45;
    const gx = cx + (px-cx)*scale;
    const gy = cy + (py-cy)*scale;
    ctx.save();
    ctx.globalAlpha = 0.22;
    neon(cx, cy, gx, cy, colors.cos, 3);
    neon(gx, cy, gx, gy, colors.sin, 3);
    neon(cx, cy, gx, gy, colors.white, 3);
    ctx.restore();
    label((cx+gx)/2, cy-20, "Same θ → same shape", colors.ok);
  }

  if(flags.specialMode){
    drawSpecialTicks(cx, cy, R);
  }

  if(flags.coMode){
    label(px-10, py+26, "Complement viewpoint", "#ddd");
  }
}
function drawSpecialTicks(cx, cy, R){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.15)";
  ctx.lineWidth = 1;
  for(const d of [0,30,45,60,90,120,135,150,180,210,225,240,270,300,315,330]){
    const a = degToRad(d);
    const x1 = cx + Math.cos(a)*(R*0.92);
    const y1 = cy - Math.sin(a)*(R*0.92);
    const x2 = cx + Math.cos(a)*(R*1.02);
    const y2 = cy - Math.sin(a)*(R*1.02);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  ctx.restore();
}

/* ---------- Tan measuring line (intuitive + precise) ---------- */
function drawTanMeasuringLine(cx, cy, R, theta){
  const measureX = cx + R; // x = 1 on unit circle scale
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(measureX, cy+80); ctx.lineTo(measureX, cy-state.h); ctx.stroke();

  // The direction line from center at angle theta.
  // Intersection with x = 1 line gives y = tan(theta).
  const c = Math.cos(theta);
  const s = Math.sin(theta);

  // cos = 0 → division by zero → tan undefined
  if(Math.abs(c) < 1e-6){
    label(measureX + 110, cy - 90, "tan is undefined here", colors.bad);
    // show the direction ray
    const px = cx + R*Math.cos(theta);
    const py = cy - R*Math.sin(theta);
    neon(cx, cy, px, py, "#fff", 3);
    return;
  }

  const t = s / c;

  // Visual clamp only (not math). Line grows without bound near 90°.
  const yHit = cy - R*t;
  const yClamped = cy - clamp(R*t, -R*3.2, R*3.2);

  // Draw the direction (white) and the hit height (yellow)
  laser(cx, cy, measureX, yClamped);

  // If it's clamped, say "grows without bound" instead of "infinite"
  const wasClamped = Math.abs(R*t) > R*3.2;

  neon(measureX, cy, measureX, yClamped, colors.tan, 4);
  label(measureX + 64, (cy+yClamped)/2, "tan(θ)", colors.tan);

  if(wasClamped){
    label(measureX + 130, yClamped, "grows without bound near 90°", colors.bad);
  } else {
    // subtle: show sign as up/down
    const note = (t>=0) ? "hits above → tan positive" : "hits below → tan negative";
    label(measureX + 140, yClamped, note, "rgba(255,255,255,0.65)");
  }

  // label measuring line
  label(measureX, cy + 44, "measuring line: x = 1", "rgba(255,255,255,0.55)");
}

/* ---------- Radians toolkit (visual + intuitive) ---------- */
function drawArcToolkit(cx, cy, R, theta){
  // 1 rad reference arc (green), always from 0 to 1 rad
  drawArc(cx, cy, R, 0, -1, "rgba(34,197,94,0.45)", 10);
  label(cx + R*0.26, cy - R*0.18, "1 rad (reference)", "rgba(34,197,94,0.95)");

  // theta arc (violet)
  const t = thetaSignedForArc(theta);
  drawArc(cx, cy, R, 0, -t, "rgba(189,0,255,0.35)", 10);
  label(cx + R*0.30, cy - R*0.06, "θ arc", "rgba(189,0,255,0.9)");

  // show arc endpoints
  dot(cx + R, cy, 4, "rgba(255,255,255,0.55)");
  const px = cx + R*Math.cos(theta);
  const py = cy - R*Math.sin(theta);
  dot(px, py, 6, "#fff");

  // show radius segment and label
  neon(cx, cy, cx+R, cy, "rgba(255,255,255,0.35)", 2);
  label(cx + R*0.5, cy + 22, "radius", "rgba(255,255,255,0.55)");
}

function drawArc(cx, cy, r, start, end, stroke, width){
  ctx.save();
  ctx.lineWidth = width;
  ctx.strokeStyle = stroke;
  ctx.beginPath();
  // arc direction: if end < start, draw anticlockwise true (because canvas y-down)
  const anticlockwise = end > start;
  ctx.arc(cx, cy, r, start, end, anticlockwise);
  ctx.stroke();
  ctx.restore();
}

/* =========================================================
   Micro readout (small, intuitive)
   ========================================================= */
function drawMicroReadout(cx, cy, px, py, theta, flags){
  const s = Math.sin(theta), c = Math.cos(theta);
  const t = (Math.abs(c)<1e-6) ? NaN : s/c;

  let x = px + 16;
  let y = py - 18;
  x = Math.max(12, Math.min(state.w-200, x));
  y = Math.max(18, Math.min(state.h-18, y));

  const lines = [];

  // Always reinforce the core idea: x and y
  lines.push({k:"x", v:fmt(c), c:"rgba(0,204,255,0.95)"});
  lines.push({k:"y", v:fmt(s), c:"rgba(255,0,85,0.95)"});

  if(flags.measureLine || flags.scene==="word"){
    lines.push({k:"tan", v:(Number.isFinite(t)?fmt(t):"undef"), c:"rgba(255,204,0,0.95)"});
  }

  const d = normDeg(radToDeg(theta));
  const snapInfo = nearestSpecialDeg(d);
  const isExact = (snapInfo.dist < 0.2);
  if(isExact && (flags.specialMode || flags.arcMode || flags.scene==="circle")){
    const ex = exactFromDeg(snapInfo.best);
    if(ex){
      lines.push({k:"sin*", v:ex.sin, c:"rgba(255,0,85,0.85)"});
      lines.push({k:"cos*", v:ex.cos, c:"rgba(0,204,255,0.85)"});
      if(flags.measureLine) lines.push({k:"tan*", v:ex.tan, c:"rgba(255,204,0,0.85)"});
      lines.push({k:"rad", v:degToPiFrac(snapInfo.best), c:"rgba(255,255,255,0.85)"});
    }
  }

  const pad=8, lh=16, w=182, h=pad*2 + lh*lines.length;

  ctx.fillStyle = "rgba(0,0,0,0.70)";
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;
  roundRect(x, y, w, h, 10, true, true);

  ctx.font = "900 12px ui-monospace, Menlo, Consolas, monospace";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";

  for(let i=0;i<lines.length;i++){
    const yy = y + pad + i*lh + lh/2;
    ctx.fillStyle = lines[i].c;
    ctx.fillText(lines[i].k.toUpperCase(), x+10, yy);
    ctx.fillStyle = "#ddd";
    ctx.fillText(lines[i].v, x+70, yy);
  }
}
function roundRect(x, y, w, h, r, fill, stroke){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* =========================================================
   Base scenes
   ========================================================= */
function drawRadius(cx, cy, px, py, R, theta){
  neon(cx, cy, px, py, colors.white, 3);
  dot(px, py, 6, "#fff");
  angleArc(cx, cy, theta, R*0.18);
}
function drawAxes(cx, cy){
  ctx.strokeStyle = colors.grid;
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(state.w, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, state.h); ctx.stroke();
}
function drawCircle(cx, cy, R){
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(cx, cy, R, 0, TAU); ctx.stroke();
}

/* =========================================================
   Word scene (FIXED: ground + tan is consistent)
   Word scene (ground + tan consistent)
   ========================================================= */
function drawWordScene(ox, oy, R, theta, flags){
  const w=state.w;

  // ground baseline
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(w, oy); ctx.stroke();

  // choose a fixed ground distance for the picture
  const ground = R*1.25;
  const baseX = ox + ground;

  // height via tan
  const height = ground * Math.tan(theta);
  const topY = oy - height;

  // building
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 6;
  ctx.beginPath(); ctx.moveTo(baseX, oy); ctx.lineTo(baseX, oy - R*1.2); ctx.stroke();

  // triangle: adj, opp, hyp
  neon(ox, oy, baseX, oy, colors.cos, 4);
  neon(baseX, oy, baseX, topY, colors.sin, 4);
  neon(ox, oy, baseX, topY, colors.white, 4);

  dot(ox, oy, 6, "#fff");
  dot(baseX, topY, 6, "#fff");

  angleArc(ox, oy, theta, 26);
  rightAngle(baseX, oy, 14);

  if(flags.labels){
    label((ox+baseX)/2, oy+18, "Ground (adjacent)", colors.cos);
    label(baseX+70, (oy+topY)/2, "Height (opposite)", colors.sin);
    label((ox+baseX)/2+20, (oy+topY)/2-12, "Line of sight", "#fff");
    label(baseX, oy + 44, "building", "rgba(255,255,255,0.55)");
  }
}

/* =========================================================
   Boot
   ========================================================= */
function buildNav(){
  const nav = document.getElementById("nav");
  nav.innerHTML = "";
  lessons.forEach((L, i) => {
    const b = document.createElement("button");
    b.textContent = L.nav;
    b.onclick = () => setLesson(i);
    b.id = `nav_${i}`;
    nav.appendChild(b);
  });
}
function updateNav(){
  lessons.forEach((_, i) => {
    const b = document.getElementById(`nav_${i}`);
    if(b) b.classList.toggle("active", i === state.lessonIndex);
  });
}
function ensureProgress(lessonId){
  if(!progress[lessonId]) progress[lessonId] = { satPassed:false };
  return progress[lessonId];
}

buildNav();
setLesson(0);
setTimeout(resize, 20);
resize();
</script>

</body>
</html>
