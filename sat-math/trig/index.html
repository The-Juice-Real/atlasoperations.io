<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>SAT Trig — Teach First, Simulate Second</title>
  <style>
    :root{
      --bg:#050505; --panel:#0a0a0a; --text:#eee; --muted:#8a8a8a;
      --sin:#ff0055; --cos:#00ccff; --tan:#ffcc00;
      --sec:#ccffff; --csc:#ffcccc; --cot:#ff8800;
      --ok:#22c55e; --bad:#ef4444; --vio:#bd00ff;
      --grid:#222; --line:#2a2a2a;
    }
    *{box-sizing:border-box}
    body{
      margin:0; height:100vh; width:100vw;
      background:var(--bg); color:var(--text);
      font-family: "Segoe UI", system-ui, sans-serif;
      display:flex; overflow:hidden;
    }

    /* LEFT STAGE */
    #stage{
      flex:1; min-width:0; position:relative; background:#000; overflow:hidden;
      cursor:crosshair;
    }
    canvas{display:block; width:100%; height:100%}

    /* Minimal HUD (small, not a spreadsheet) */
    #hud{
      position:absolute; top:14px; left:14px; z-index:20;
      background:rgba(10,10,10,.82);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 12px;
      display:flex; gap:10px; align-items:flex-start;
      backdrop-filter: blur(6px);
    }
    #hud .k{font-size:.72rem; letter-spacing:1.5px; text-transform:uppercase; color:#777}
    #hud .v{font-weight:900; font-size:1.05rem; line-height:1.1}
    #hud .s{font-size:.85rem; color:#aaa; margin-top:2px}
    .pill{
      padding:6px 10px; border-radius:999px;
      border:1px solid #333; background:rgba(255,255,255,.05);
      color:#ddd; font-weight:800; font-size:.72rem;
      user-select:none;
    }
    .pill.ok{border-color:rgba(34,197,94,.45); color:#c7f9d6}
    .pill.bad{border-color:rgba(239,68,68,.45); color:#ffd1d1}

    /* Micro readout toggle */
    #microbar{
      position:absolute; top:14px; right:14px; z-index:20;
      background:rgba(10,10,10,.82);
      border:1px solid var(--line);
      border-radius:12px;
      padding:8px 10px;
      display:flex; gap:8px; align-items:center;
      backdrop-filter: blur(6px);
    }
    #microbar button{
      border:none; cursor:pointer;
      padding:8px 10px; border-radius:10px;
      background:rgba(255,255,255,.06);
      color:#ddd; font-weight:900; font-size:.75rem;
    }
    #microbar button.active{
      background:#fff; color:#000;
    }

    /* BOTTOM NAV */
    #nav{
      position:absolute; bottom:16px; left:50%; transform:translateX(-50%);
      z-index:20; display:flex; gap:8px;
      background:rgba(10,10,10,.90);
      border:1px solid #333;
      border-radius:16px;
      padding:10px;
      max-width:95%;
      overflow-x:auto; white-space:nowrap; scrollbar-width:none;
    }
    #nav::-webkit-scrollbar{display:none}
    #nav button{
      border:none; cursor:pointer;
      padding:9px 12px; border-radius:12px;
      background:transparent; color:#888;
      font-weight:900; letter-spacing:.4px; text-transform:uppercase;
      font-size:.72rem;
      transition:.15s;
    }
    #nav button:hover{color:#fff; background:rgba(255,255,255,.08)}
    #nav button.active{background:#fff; color:#000}

    /* RIGHT PANEL = LESSON, not numbers */
    #panel{
      width:460px; flex-shrink:0;
      background:var(--panel);
      border-left:1px solid #222;
      display:flex; flex-direction:column;
    }
    #panelTop{
      padding:18px 18px 12px 18px;
      border-bottom:1px solid #1f1f1f;
    }
    #title{
      margin:0; font-size:1.45rem; letter-spacing:-.5px; line-height:1.15;
      font-weight:950;
    }
    #subtitle{
      margin:8px 0 0 0;
      color:#8f8f8f; font-size:.92rem; line-height:1.35;
    }

    /* Layer buttons enforce the sequence */
    #layers{
      margin-top:12px;
      display:grid; grid-template-columns:repeat(4,1fr); gap:8px;
    }
    #layers button{
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:10px 8px;
      background:#070707;
      color:#bbb;
      font-weight:950;
      font-size:.72rem;
      letter-spacing:1.4px;
      text-transform:uppercase;
      cursor:pointer;
    }
    #layers button.active{
      background:#fff; color:#000; border-color:#fff;
    }
    #layers button.locked{
      opacity:.35; cursor:not-allowed;
    }

    #body{
      padding:16px 18px 18px 18px;
      overflow:auto;
      flex:1;
    }
    p{margin:0 0 12px 0; color:#c0c0c0; line-height:1.6; font-size:.95rem}
    strong{color:#fff}
    ul{margin:0 0 12px 18px; color:#c0c0c0}
    li{margin:6px 0}
    .box{
      border:1px solid #2b2b2b;
      background:rgba(255,255,255,.05);
      border-radius:14px;
      padding:12px 12px;
      margin:12px 0;
    }
    .box.ok{border-color:rgba(34,197,94,.35); background:rgba(34,197,94,.07)}
    .box.bad{border-color:rgba(239,68,68,.35); background:rgba(239,68,68,.07)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace}
    .tag{
      display:inline-block; padding:2px 8px; border-radius:999px;
      background:rgba(255,255,255,.07); border:1px solid #2b2b2b;
      color:#ddd; font-weight:900; font-size:.74rem; letter-spacing:.4px;
    }
    .sat{
      border:1px solid #2b2b2b;
      background:#060606;
      border-radius:14px;
      padding:12px;
    }
    .sat .q{
      color:#e8e8e8; font-weight:900; margin-bottom:8px;
    }
    .sat .a{
      color:#bdbdbd; font-size:.92rem; line-height:1.55;
    }
    .sat .map{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #232323;
      background:rgba(255,255,255,.04);
      color:#cfcfcf;
    }

    #panelBottom{
      padding:12px 18px;
      border-top:1px solid #1f1f1f;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    #panelBottom .left, #panelBottom .right{display:flex; gap:10px}
    #panelBottom button{
      border:none; cursor:pointer;
      padding:10px 12px; border-radius:12px;
      background:rgba(255,255,255,.08); color:#ddd; font-weight:950;
    }
    #panelBottom button.primary{
      background:#fff; color:#000;
    }
    #panelBottom button:disabled{
      opacity:.35; cursor:not-allowed;
    }

    @media (max-width: 820px){
      body{flex-direction:column}
      #panel{width:100%; height:52%}
      #stage{height:48%}
      #microbar{top:64px}
    }
  </style>
</head>
<body>

<div id="stage">
  <canvas id="cvs"></canvas>

  <div id="hud">
    <div>
      <div class="k">ANGLE</div>
      <div class="v" id="hudTheta">θ = 0°</div>
      <div class="s" id="hudEq">Equivalent: 0°</div>
    </div>
    <div class="pill ok" id="hudQuad">QI</div>
    <div class="pill" id="hudRef">ref 0°</div>
  </div>

  <div id="microbar">
    <button id="btnReadout" class="active" title="Show small values on the canvas">READOUT</button>
    <button id="btnSnap" class="" title="Snap θ to SAT special angles">SNAP</button>
  </div>

  <div id="nav"></div>
</div>

<div id="panel">
  <div id="panelTop">
    <h1 id="title"></h1>
    <div id="subtitle"></div>

    <div id="layers">
      <button id="layer0" onclick="setLayer(0)">1 Visual</button>
      <button id="layer1" onclick="setLayer(1)">2 Concept</button>
      <button id="layer2" onclick="setLayer(2)">3 Math</button>
      <button id="layer3" onclick="setLayer(3)">4 SAT</button>
    </div>
  </div>

  <div id="body"></div>

  <div id="panelBottom">
    <div class="left">
      <button id="btnPrev" onclick="prevLesson()">Prev</button>
      <button id="btnNext" onclick="nextLesson()">Next</button>
    </div>
    <div class="right">
      <button id="btnBackLayer" onclick="prevLayer()">Back Step</button>
      <button class="primary" id="btnForwardLayer" onclick="nextLayer()">Next Step</button>
    </div>
  </div>
</div>

<script>
/* =========================================================
   Teaching-first engine
   Goal: Visual -> Concept -> Math -> SAT, per section.
   No constant right-side number spam.
   Small readout sits on the canvas when you want it.
   ========================================================= */

const cvs = document.getElementById("cvs");
const ctx = cvs.getContext("2d", {alpha:false});

const colors = {
  bg:"#050505", grid:"#222",
  sin:"#ff0055", cos:"#00ccff", tan:"#ffcc00",
  white:"#fff", muted:"#888", ok:"#22c55e", bad:"#ef4444",
  vio:"#bd00ff"
};

const SPECIAL = [0,30,45,60,90,120,135,150,180,210,225,240,270,300,315,330,360];

const state = {
  w:0,h:0,cx:0,cy:0,R:220,
  theta: 0.65,      // radians (raw, can be negative)
  dragging:false,
  readout:true,
  snap:false,
  lessonIndex:0,
  layerIndex:0,
  unlockedLayer:0
};

function radToDeg(r){ return r*180/Math.PI; }
function degToRad(d){ return d*Math.PI/180; }
function normDeg(d){
  let x = d%360; if(x<0) x+=360;
  if(Math.abs(x-360)<1e-9) x=0;
  return x;
}
function normRad(r){
  let x = r%(2*Math.PI); if(x<0) x+=2*Math.PI;
  if(Math.abs(x-2*Math.PI)<1e-9) x=0;
  return x;
}
function quadrantFromDeg(d0){
  const d = normDeg(d0);
  if(d===0) return "Axis +x";
  if(d===90) return "Axis +y";
  if(d===180) return "Axis -x";
  if(d===270) return "Axis -y";
  if(d>0 && d<90) return "QI";
  if(d>90 && d<180) return "QII";
  if(d>180 && d<270) return "QIII";
  return "QIV";
}
function referenceAngleDeg(d0){
  const d = normDeg(d0);
  if(d>=0 && d<=90) return d;
  if(d>90 && d<180) return 180-d;
  if(d>=180 && d<=270) return d-180;
  if(d>270 && d<360) return 360-d;
  return 0;
}
function signPack(d0){
  const d = normDeg(d0);
  if(d===0) return {sin:0, cos:+1};
  if(d===90) return {sin:+1, cos:0};
  if(d===180) return {sin:0, cos:-1};
  if(d===270) return {sin:-1, cos:0};
  if(d>0 && d<90) return {sin:+1, cos:+1};
  if(d>90 && d<180) return {sin:+1, cos:-1};
  if(d>180 && d<270) return {sin:-1, cos:-1};
  return {sin:-1, cos:+1};
}
function nearestSpecialDeg(d0){
  const d = normDeg(d0);
  let best=SPECIAL[0], bestDist=1e9;
  for(const s of SPECIAL){
    const dist = Math.min(Math.abs(d-s), Math.abs((d+360)-s), Math.abs(d-(s+360)));
    if(dist<bestDist){ bestDist=dist; best=s; }
  }
  return {best, dist:bestDist};
}
function fmt(x){
  if(!Number.isFinite(x)) return "undef";
  const ax=Math.abs(x);
  if(ax<1e-4) return "0";
  return x.toFixed(3);
}

/* =========================================================
   Lessons: each lesson defines:
   - title/subtitle
   - per layer: (visual config + text + sat example)
   - draw flags that change visuals to match the teaching step
   ========================================================= */

const LAYERS = ["Visual","Concept","Math","SAT"];

const lessons = [
  {
    id:"unit",
    nav:"0 Unit Circle",
    title:"Unit Circle: make it visual first",
    subtitle:"You move θ. The point moves. That’s the foundation. No formulas yet.",
    layers:[
      {
        // VISUAL
        flags:{circle:true, triangle:false, projections:false, labels:false, walls:false, quadrants:false},
        html:`
          <p><strong>Do this:</strong> drag on the left stage. Watch the point move around the circle.</p>
          <div class="box">
            <p><strong>What you should notice:</strong></p>
            <ul>
              <li>The circle is the “track.”</li>
              <li>θ is the “steering wheel.”</li>
              <li>The point is the only thing that matters right now.</li>
            </ul>
          </div>
          <p class="tag">Goal: your brain accepts “angle = position” before any math appears.</p>
        `
      },
      {
        // CONCEPT
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false},
        html:`
          <p><strong>Concept:</strong> the point has two coordinates.</p>
          <div class="box">
            <ul>
              <li><strong>Horizontal</strong> coordinate = how far right/left.</li>
              <li><strong>Vertical</strong> coordinate = how far up/down.</li>
            </ul>
          </div>
          <p>On this app:</p>
          <ul>
            <li><span style="color:var(--cos)"><strong>Blue</strong></span> is horizontal.</li>
            <li><span style="color:var(--sin)"><strong>Pink</strong></span> is vertical.</li>
          </ul>
        `
      },
      {
        // MATH
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false},
        html:`
          <p><strong>Math translation:</strong></p>
          <div class="box ok">
            <p class="mono"><strong>(x, y) = (cos θ, sin θ)</strong></p>
            <p>That’s it. That’s the “unit circle” statement.</p>
          </div>
          <div class="box bad">
            <p><strong>SAT trap:</strong> mixing them up.</p>
            <p><span class="mono">cos</span> is <strong>x</strong>. <span class="mono">sin</span> is <strong>y</strong>. Always.</p>
          </div>
        `
      },
      {
        // SAT
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              Point P is on the unit circle. If P has coordinates <span class="mono">(0.6, 0.8)</span>, what is <span class="mono">sin(θ)</span>?
            </div>
            <div class="map">
              <p><strong>Mapping:</strong></p>
              <ul>
                <li><span class="mono">x = cos θ</span> → here <span class="mono">cos θ = 0.6</span></li>
                <li><span class="mono">y = sin θ</span> → here <span class="mono">sin θ = 0.8</span></li>
              </ul>
              <p><strong>Answer is literally the y-value.</strong></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"soh",
    nav:"1 SOHCAHTOA",
    title:"SOHCAHTOA: sides are relative to θ",
    subtitle:"SAT doesn’t test “what is sine?” It tests “which ratio should I use?”",
    layers:[
      {
        flags:{circle:true, triangle:true, projections:false, labels:false, walls:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <p><strong>Visual:</strong> this is a right triangle sitting inside the circle.</p>
          <div class="box">
            <p><strong>Look only at names:</strong></p>
            <ul>
              <li><strong>Hyp</strong> = the long slanted side.</li>
              <li><strong>Opp</strong> = directly across from θ.</li>
              <li><strong>Adj</strong> = next to θ (touching it).</li>
            </ul>
          </div>
          <div class="box bad">
            <p><strong>Trap:</strong> students label “up” as Opp forever.</p>
            <p>Wrong. Opp changes when θ changes.</p>
          </div>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <p><strong>Concept:</strong> ratios ignore scale.</p>
          <div class="box ok">
            <p>If the triangle gets bigger, sides grow… but the ratios stay the same.</p>
            <p>That’s why trig works.</p>
          </div>
          <p>SOHCAHTOA is just a menu:</p>
          <ul>
            <li><strong>SOH</strong>: <span class="mono">sin = Opp/Hyp</span></li>
            <li><strong>CAH</strong>: <span class="mono">cos = Adj/Hyp</span></li>
            <li><strong>TOA</strong>: <span class="mono">tan = Opp/Adj</span></li>
          </ul>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <p><strong>Math:</strong> the three definitions.</p>
          <div class="box">
            <p class="mono">sin θ = Opp/Hyp</p>
            <p class="mono">cos θ = Adj/Hyp</p>
            <p class="mono">tan θ = Opp/Adj</p>
          </div>
          <div class="box bad">
            <p><strong>Non-negotiable SAT rule:</strong></p>
            <p>You pick a ratio because it contains what you <strong>have</strong> and what you <strong>need</strong>.</p>
          </div>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              In a right triangle, θ is an acute angle. The side opposite θ is 9 and the hypotenuse is 15.
              What is <span class="mono">sin(θ)</span>?
            </div>
            <div class="map">
              <p><strong>Given → Asked:</strong></p>
              <ul>
                <li>Given: Opp and Hyp</li>
                <li>Asked: sin</li>
              </ul>
              <p><strong>Pick the ratio that uses Opp and Hyp:</strong> <span class="mono">sin = Opp/Hyp</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"scale",
    nav:"2 Scaling",
    title:"Scaling: turn ratios into side lengths",
    subtitle:"This is where SAT problems become “build one equation and solve.”",
    layers:[
      {
        flags:{circle:true, triangle:true, projections:true, labels:false, walls:false, quadrants:false, scaleDemo:true},
        html:`
          <p><strong>Visual:</strong> the triangle “zooms.” Ratios don’t care.</p>
          <div class="box">
            <p>Imagine hypotenuse is not 1 anymore.</p>
            <p>Same θ. Bigger triangle.</p>
          </div>
          <p class="tag">Goal: accept “ratio × known side = unknown side”.</p>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, scaleDemo:true},
        html:`
          <p><strong>Concept:</strong> similar triangles.</p>
          <div class="box ok">
            <p>When θ stays the same, the triangle’s shape stays the same.</p>
            <p>Only the size changes.</p>
          </div>
          <p>So if you know one side, you can compute the others with trig ratios.</p>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, scaleDemo:true},
        html:`
          <p><strong>Math tools SAT expects you to build instantly:</strong></p>
          <div class="box">
            <p class="mono">Opp = Hyp · sin θ</p>
            <p class="mono">Adj = Hyp · cos θ</p>
            <p class="mono">Opp = Adj · tan θ</p>
          </div>
          <div class="box bad">
            <p><strong>Trap:</strong> using tan when you have Hyp. Tan doesn’t include Hyp. That wastes your information.</p>
          </div>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, scaleDemo:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              A right triangle has hypotenuse 10 and angle θ. If <span class="mono">sin(θ)=0.6</span>,
              what is the length of the side opposite θ?
            </div>
            <div class="map">
              <p><strong>Translate:</strong> <span class="mono">sin = Opp/Hyp</span></p>
              <p><strong>Build:</strong> <span class="mono">0.6 = Opp/10</span></p>
              <p><strong>So:</strong> <span class="mono">Opp = 10·0.6</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"special",
    nav:"3 Special Angles",
    title:"Special angles: exact values, zero decimals",
    subtitle:"SAT loves √2/2 and √3/2. If you hesitate, you lose time.",
    layers:[
      {
        flags:{circle:true, triangle:true, projections:true, labels:false, walls:false, quadrants:false, specialMode:true},
        html:`
          <p><strong>Visual:</strong> turn SNAP on. Drag. It locks to SAT angles.</p>
          <div class="box">
            <p>These are the angles SAT keeps recycling:</p>
            <p class="mono">0, 30, 45, 60, 90, …</p>
          </div>
          <p class="tag">Goal: your eye recognizes these positions.</p>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, specialMode:true},
        html:`
          <p><strong>Concept:</strong> all exact values come from two triangles:</p>
          <div class="box ok">
            <p><strong>30-60-90:</strong> <span class="mono">1 : √3 : 2</span></p>
            <p><strong>45-45-90:</strong> <span class="mono">1 : 1 : √2</span></p>
          </div>
          <p>Unit circle values are those ratios scaled to hypotenuse 1.</p>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, specialMode:true},
        html:`
          <p><strong>Math:</strong> the core exact ones (Quadrant I):</p>
          <div class="box">
            <p class="mono">sin 30 = 1/2</p>
            <p class="mono">cos 30 = √3/2</p>
            <p class="mono">sin 45 = √2/2</p>
            <p class="mono">cos 45 = √2/2</p>
            <p class="mono">sin 60 = √3/2</p>
            <p class="mono">cos 60 = 1/2</p>
          </div>
          <div class="box bad">
            <p><strong>Rule:</strong> SAT wants exact forms. Decimals are bait.</p>
          </div>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, specialMode:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              What is <span class="mono">sin(π/3)</span>?
            </div>
            <div class="map">
              <p><strong>Translate:</strong> <span class="mono">π/3 = 60°</span></p>
              <p><strong>Recall:</strong> <span class="mono">sin 60 = √3/2</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"quadrants",
    nav:"4 Quadrants",
    title:"Quadrants: same reference angle, different signs",
    subtitle:"This is where most students start hallucinating. Fix that.",
    layers:[
      {
        flags:{circle:true, triangle:true, projections:true, labels:false, walls:false, quadrants:true},
        html:`
          <p><strong>Visual:</strong> drag θ into every quadrant. Watch what flips.</p>
          <div class="box">
            <ul>
              <li>Right/left decides the sign of cosine (x).</li>
              <li>Up/down decides the sign of sine (y).</li>
            </ul>
          </div>
          <p class="tag">Goal: you see signs before you compute anything.</p>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:true},
        html:`
          <p><strong>Concept:</strong> reference angle is the “acute copy.”</p>
          <div class="box ok">
            <p>You find the acute angle to the x-axis.</p>
            <p>You grab the exact values from Quadrant I.</p>
            <p>Then you apply signs based on the quadrant.</p>
          </div>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:true},
        html:`
          <p><strong>Math signs table (sin, cos, tan):</strong></p>
          <div class="box">
            <p class="mono">QI: + + +</p>
            <p class="mono">QII: + − −</p>
            <p class="mono">QIII: − − +</p>
            <p class="mono">QIV: − + −</p>
          </div>
          <div class="box bad">
            <p><strong>Trap:</strong> getting the magnitude right but the sign wrong.</p>
            <p>That is still 0 points.</p>
          </div>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              If θ = 210°, what is <span class="mono">cos(θ)</span>?
            </div>
            <div class="map">
              <p><strong>Step 1:</strong> reference angle = 30°</p>
              <p><strong>Step 2:</strong> cos 30 = √3/2</p>
              <p><strong>Step 3:</strong> 210° is QIII → cos is negative</p>
              <p><strong>Result:</strong> <span class="mono">−√3/2</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"tan",
    nav:"5 Tan & Slope",
    title:"Tan: the slope of the angle",
    subtitle:"SAT hides tan in coordinate geometry. This connects them.",
    layers:[
      {
        flags:{circle:true, triangle:true, projections:true, labels:false, walls:true, quadrants:false},
        html:`
          <p><strong>Visual:</strong> the yellow wall is “run = 1”. The vertical is “rise”.</p>
          <div class="box">
            <p>As θ rotates, the slope changes.</p>
            <p>That slope is <strong>tan</strong>.</p>
          </div>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:true, quadrants:false},
        html:`
          <p><strong>Concept:</strong> slope = rise/run.</p>
          <div class="box ok">
            <p><strong>rise</strong> = Opp</p>
            <p><strong>run</strong> = Adj</p>
            <p>So <strong>tan</strong> is literally <strong>Opp/Adj</strong>.</p>
          </div>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:true, quadrants:false},
        html:`
          <p><strong>Math:</strong></p>
          <div class="box">
            <p class="mono">tan θ = Opp/Adj</p>
            <p class="mono">tan θ = sin θ / cos θ</p>
          </div>
          <div class="box bad">
            <p><strong>Key SAT warning:</strong> tan is undefined when cos = 0 (90°, 270°).</p>
          </div>
        `
      },
      {
        flags:{circle:true, triangle:true, projections:true, labels:true, walls:true, quadrants:false},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              A line makes an angle θ with the positive x-axis. If the slope of the line is 3, what is <span class="mono">tan(θ)</span>?
            </div>
            <div class="map">
              <p><strong>Mapping:</strong> tan θ = slope</p>
              <p><strong>So:</strong> <span class="mono">tan(θ)=3</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"word",
    nav:"6 Word Problems",
    title:"Word problems: same triangle, different nouns",
    subtitle:"SAT swaps words to make you forget it’s trig. Don’t.",
    layers:[
      {
        flags:{circle:false, triangle:true, projections:true, labels:false, walls:false, quadrants:false, wordScene:true},
        html:`
          <p><strong>Visual:</strong> height, ground distance, line-of-sight.</p>
          <div class="box">
            <p>Set θ with drag.</p>
            <p>See which side is “height” (vertical) and which is “ground” (horizontal).</p>
          </div>
        `
      },
      {
        flags:{circle:false, triangle:true, projections:true, labels:true, walls:false, quadrants:false, wordScene:true},
        html:`
          <p><strong>Concept translation table:</strong></p>
          <div class="box ok">
            <ul>
              <li><strong>Height</strong> → Opp (usually)</li>
              <li><strong>Ground distance</strong> → Adj (usually)</li>
              <li><strong>Ladder/cable</strong> → Hyp (usually)</li>
            </ul>
          </div>
          <div class="box bad">
            <p><strong>Trap:</strong> “angle of depression” is the same angle as elevation (geometry), so do not panic.</p>
          </div>
        `
      },
      {
        flags:{circle:false, triangle:true, projections:true, labels:true, walls:false, quadrants:false, wordScene:true},
        html:`
          <p><strong>Math patterns SAT repeats:</strong></p>
          <div class="box">
            <p class="mono">height = distance · tan θ</p>
            <p class="mono">height = hypotenuse · sin θ</p>
          </div>
          <p>Pick based on which lengths are given.</p>
        `
      },
      {
        flags:{circle:false, triangle:true, projections:true, labels:true, walls:false, quadrants:false, wordScene:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              From a point 80 meters from a building, the angle of elevation to the top is 28°. Approximately how tall is the building?
            </div>
            <div class="map">
              <p><strong>Map the words:</strong></p>
              <ul>
                <li>ground distance = Adj = 80</li>
                <li>height = Opp = ?</li>
              </ul>
              <p><strong>Pick ratio:</strong> <span class="mono">tan = Opp/Adj</span></p>
              <p><strong>Build:</strong> <span class="mono">Opp = 80·tan(28°)</span></p>
            </div>
          </div>
        `
      }
    ]
  }
];

/* =========================================================
   UI wiring (nav + layers)
   ========================================================= */

const nav = document.getElementById("nav");

function buildNav(){
  nav.innerHTML = "";
  lessons.forEach((L, i) => {
    const b = document.createElement("button");
    b.textContent = L.nav;
    b.onclick = () => setLesson(i);
    b.id = `nav_${i}`;
    nav.appendChild(b);
  });
}

function setLesson(i){
  state.lessonIndex = i;
  state.layerIndex = 0;
  state.unlockedLayer = 0;

  updatePanel();
  updateNav();
  draw();
  updateHud();
}

function setLayer(k){
  if(k > state.unlockedLayer) return;
  state.layerIndex = k;
  updatePanel();
  draw();
}

function nextLayer(){
  if(state.layerIndex < 3){
    state.unlockedLayer = Math.max(state.unlockedLayer, state.layerIndex + 1);
    state.layerIndex++;
    updatePanel();
    draw();
  }
}
function prevLayer(){
  if(state.layerIndex > 0){
    state.layerIndex--;
    updatePanel();
    draw();
  }
}
function nextLesson(){
  if(state.lessonIndex < lessons.length-1) setLesson(state.lessonIndex+1);
}
function prevLesson(){
  if(state.lessonIndex > 0) setLesson(state.lessonIndex-1);
}

function updateNav(){
  lessons.forEach((_, i) => {
    const b = document.getElementById(`nav_${i}`);
    if(!b) return;
    b.classList.toggle("active", i === state.lessonIndex);
  });
}

function updatePanel(){
  const L = lessons[state.lessonIndex];
  const layer = L.layers[state.layerIndex];

  document.getElementById("title").textContent = L.title;
  document.getElementById("subtitle").textContent = L.subtitle;
  document.getElementById("body").innerHTML = layer.html;

  // layer buttons
  for(let k=0;k<4;k++){
    const btn = document.getElementById(`layer${k}`);
    btn.classList.toggle("active", k === state.layerIndex);
    const locked = k > state.unlockedLayer;
    btn.classList.toggle("locked", locked);
    btn.disabled = locked;
  }

  // bottom buttons
  document.getElementById("btnBackLayer").disabled = state.layerIndex === 0;
  document.getElementById("btnForwardLayer").disabled = state.layerIndex === 3;
  document.getElementById("btnPrev").disabled = state.lessonIndex === 0;
  document.getElementById("btnNext").disabled = state.lessonIndex === lessons.length-1;
}

window.setLayer = setLayer;
window.nextLayer = nextLayer;
window.prevLayer = prevLayer;
window.nextLesson = nextLesson;
window.prevLesson = prevLesson;

/* =========================================================
   Controls: readout + snap
   ========================================================= */
const btnReadout = document.getElementById("btnReadout");
const btnSnap = document.getElementById("btnSnap");

btnReadout.addEventListener("click", () => {
  state.readout = !state.readout;
  btnReadout.classList.toggle("active", state.readout);
  draw();
});
btnSnap.addEventListener("click", () => {
  state.snap = !state.snap;
  btnSnap.classList.toggle("active", state.snap);
  draw();
});

/* =========================================================
   Input (drag angle)
   ========================================================= */
function interact(px, py){
  const dx = px - state.cx;
  const dy = py - state.cy;
  let ang = Math.atan2(-dy, dx); // raw
  state.theta = ang;

  if(state.snap){
    const d = normDeg(radToDeg(state.theta));
    const {best, dist} = nearestSpecialDeg(d);
    if(dist < 2.0) state.theta = degToRad(best);
  }

  draw();
  updateHud();
}

cvs.addEventListener("mousedown", e => {
  state.dragging = true;
  interact(e.offsetX, e.offsetY);
});
window.addEventListener("mousemove", e => {
  if(!state.dragging) return;
  const r = cvs.getBoundingClientRect();
  interact(e.clientX - r.left, e.clientY - r.top);
});
window.addEventListener("mouseup", () => state.dragging=false);

cvs.addEventListener("touchstart", e => {
  e.preventDefault();
  state.dragging = true;
  const r = cvs.getBoundingClientRect();
  interact(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
}, {passive:false});

cvs.addEventListener("touchmove", e => {
  e.preventDefault();
  if(!state.dragging) return;
  const r = cvs.getBoundingClientRect();
  interact(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
}, {passive:false});

cvs.addEventListener("touchend", () => state.dragging=false);

/* =========================================================
   Resize
   ========================================================= */
function resize(){
  const p = cvs.parentElement;
  state.w = p.clientWidth;
  state.h = p.clientHeight;
  cvs.width = state.w;
  cvs.height = state.h;

  state.cx = state.w * 0.38;
  state.cy = state.h * 0.64;
  state.R  = Math.min(state.w, state.h) * 0.30;

  draw();
  updateHud();
}
window.addEventListener("resize", resize);

/* =========================================================
   HUD
   ========================================================= */
function updateHud(){
  const rawDeg = radToDeg(state.theta);
  const eqDeg = normDeg(rawDeg);
  const ref = referenceAngleDeg(eqDeg);
  const quad = quadrantFromDeg(eqDeg);

  document.getElementById("hudTheta").textContent = `θ = ${rawDeg.toFixed(0)}°`;
  document.getElementById("hudEq").textContent = `Equivalent: ${eqDeg.toFixed(0)}°`;
  document.getElementById("hudQuad").textContent = quad;
  document.getElementById("hudRef").textContent = `ref ${ref.toFixed(0)}°`;

  const qPill = document.getElementById("hudQuad");
  qPill.classList.remove("ok","bad");
  qPill.classList.add(quad.startsWith("Axis") ? "bad" : "ok");
}

/* =========================================================
   Drawing engine with lesson flags
   ========================================================= */

function draw(){
  if(state.w === 0 || state.h === 0) return;

  const L = lessons[state.lessonIndex];
  const flags = L.layers[state.layerIndex].flags;

  ctx.fillStyle = colors.bg;
  ctx.fillRect(0,0,state.w,state.h);

  // Choose a scene anchor.
  // Word scene uses a ground baseline; unit circle scenes use axes + circle.
  if(flags.wordScene){
    drawWordScene(flags);
    return;
  }

  drawAxes();

  if(flags.quadrants) shadeQuadrants();
  if(flags.circle) drawCircle();

  const ang = normRad(state.theta);

  // point on circle (unit radius visual)
  const px = state.cx + state.R * Math.cos(ang);
  const py = state.cy - state.R * Math.sin(ang);

  if(flags.triangle){
    drawTriangle(px, py, flags);
  } else {
    drawRadius(px, py, flags);
  }

  // tangent wall (tan)
  if(flags.walls) drawWalls(ang);

  // readout on canvas only when requested
  if(state.readout){
    drawMicroReadout(ang, px, py, flags);
  }
}

function drawAxes(){
  ctx.strokeStyle = colors.grid;
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, state.cy); ctx.lineTo(state.w, state.cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(state.cx, 0); ctx.lineTo(state.cx, state.h); ctx.stroke();
}

function drawCircle(){
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(state.cx, state.cy, state.R, 0, Math.PI*2); ctx.stroke();
}

function shadeQuadrants(){
  const cx=state.cx, cy=state.cy, R=state.R;
  ctx.save();
  ctx.globalAlpha = 0.10;

  ctx.fillStyle = colors.ok; // QI
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,R,0,Math.PI/2,true); ctx.closePath(); ctx.fill();

  ctx.fillStyle = colors.cos; // QII
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,R,Math.PI/2,Math.PI,true); ctx.closePath(); ctx.fill();

  ctx.fillStyle = colors.sin; // QIII
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,R,Math.PI,3*Math.PI/2,true); ctx.closePath(); ctx.fill();

  ctx.fillStyle = colors.tan; // QIV
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,R,3*Math.PI/2,2*Math.PI,true); ctx.closePath(); ctx.fill();

  ctx.restore();
}

function drawRadius(px, py){
  neon(state.cx, state.cy, px, py, colors.white, 3);
  dot(px, py, 6, "#fff");
  angleArc(state.cx, state.cy, normRad(state.theta), state.R*0.18);
}

function drawTriangle(px, py, flags){
  const cx=state.cx, cy=state.cy;

  // Adj (horizontal)
  neon(cx, cy, px, cy, colors.cos, flags.showOppAdjHyp ? 4 : 3);
  // Opp (vertical)
  neon(px, cy, px, py, colors.sin, flags.showOppAdjHyp ? 4 : 3);
  // Hyp
  neon(cx, cy, px, py, colors.white, flags.showOppAdjHyp ? 4 : 3);

  dot(px, py, 6, "#fff");
  angleArc(cx, cy, normRad(state.theta), state.R*0.16);

  if(flags.labels){
    if(flags.showOppAdjHyp){
      label((cx+px)/2, cy+18, "Adj", colors.cos);
      label(px+28, (cy+py)/2, "Opp", colors.sin);
      label((cx+px)/2+12, (cy+py)/2-12, "Hyp", "#fff");
    } else {
      label((cx+px)/2, cy+18, "cos θ", colors.cos);
      label(px+30, (cy+py)/2, "sin θ", colors.sin);
      label((cx+px)/2+10, (cy+py)/2-12, "radius", "#fff");
    }
  }

  // right angle marker at (px, cy)
  rightAngle(px, cy, 14);

  // scaling demo: show a second similar triangle (ghost) so they SEE similarity
  if(flags.scaleDemo){
    const scale = 1.45;
    const gx = cx + (px-cx)*scale;
    const gy = cy + (py-cy)*scale;
    ctx.save();
    ctx.globalAlpha = 0.22;
    neon(cx, cy, gx, cy, colors.cos, 3);
    neon(gx, cy, gx, gy, colors.sin, 3);
    neon(cx, cy, gx, gy, colors.white, 3);
    ctx.restore();
    label((cx+gx)/2, cy-20, "Same θ, bigger triangle", colors.ok);
  }

  // special mode: lightly mark special angles around
  if(flags.specialMode){
    drawSpecialTicks();
  }
}

function drawSpecialTicks(){
  const cx=state.cx, cy=state.cy, R=state.R;
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.15)";
  ctx.lineWidth = 1;

  for(const d of [0,30,45,60,90,120,135,150,180,210,225,240,270,300,315,330]){
    const a = degToRad(d);
    const x1 = cx + Math.cos(a)*(R*0.92);
    const y1 = cy - Math.sin(a)*(R*0.92);
    const x2 = cx + Math.cos(a)*(R*1.02);
    const y2 = cy - Math.sin(a)*(R*1.02);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  ctx.restore();
}

function drawWalls(ang){
  const cx=state.cx, cy=state.cy, R=state.R;
  const wallX = cx + R;

  ctx.strokeStyle = "#333";
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(wallX, cy+60); ctx.lineTo(wallX, cy-state.h); ctx.stroke();

  const c = Math.cos(ang);
  if(Math.abs(c) < 1e-4){
    label(wallX+60, cy-90, "tan undefined", colors.bad);
    return;
  }
  const tanY = cy - R*Math.tan(ang);

  neon(wallX, cy, wallX, tanY, colors.tan, 4);
  laser(cx, cy, wallX, tanY);
  label(wallX+42, (cy+tanY)/2, "tan θ", colors.tan);
}

function drawMicroReadout(ang, px, py, flags){
  // tiny. lives near the drawing. not a right-panel spreadsheet.
  const s = Math.sin(ang), c = Math.cos(ang);
  const t = (Math.abs(c)<1e-6) ? Infinity : s/c;

  // put the tiny text near the point but keep it inside screen bounds
  let x = px + 16;
  let y = py - 18;
  x = Math.max(12, Math.min(state.w-160, x));
  y = Math.max(18, Math.min(state.h-18, y));

  const lines = [];
  if(flags.triangle || flags.projections || flags.labels || flags.circle){
    lines.push({k:"sin", v:fmt(s), c:colors.sin});
    lines.push({k:"cos", v:fmt(c), c:colors.cos});
  }
  if(lessons[state.lessonIndex].id === "tan"){
    lines.push({k:"tan", v:(Number.isFinite(t)?fmt(t):"undef"), c:colors.tan});
  }

  if(lines.length === 0) return;

  // background box
  const pad=8, lh=16, w=140, h=pad*2 + lh*lines.length;
  ctx.fillStyle = "rgba(0,0,0,0.70)";
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;
  roundRect(x, y, w, h, 10, true, true);

  ctx.font = "800 12px ui-monospace, Menlo, Consolas, monospace";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";

  for(let i=0;i<lines.length;i++){
    const yy = y + pad + i*lh + lh/2;
    ctx.fillStyle = lines[i].c;
    ctx.fillText(lines[i].k.toUpperCase(), x+10, yy);
    ctx.fillStyle = "#ddd";
    ctx.fillText(lines[i].v, x+58, yy);
  }
}

/* Word scene: ground + height triangle (no circle) */
function drawWordScene(flags){
  const w=state.w, h=state.h;
  const cx = state.w*0.22;
  const cy = state.h*0.78;

  // redefine anchor for this scene
  state.cx = cx;
  state.cy = cy;
  state.R  = Math.min(state.w, state.h)*0.30;

  // ground line
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();

  // vertical "building"
  const baseX = cx + state.R*1.2;
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 6;
  ctx.beginPath(); ctx.moveTo(baseX, cy); ctx.lineTo(baseX, cy - state.R*1.1); ctx.stroke();

  // angle at observer
  const ang = Math.min(Math.max(normRad(state.theta), degToRad(5)), degToRad(80));
  const hypLen = state.R*1.15;
  const hx = cx + hypLen*Math.cos(ang);
  const hy = cy - hypLen*Math.sin(ang);

  // adj = ground distance from observer to wall base projection
  neon(cx, cy, baseX, cy, colors.cos, 4);
  // opp = height up the wall
  neon(baseX, cy, baseX, hy, colors.sin, 4);
  // hyp = line of sight
  neon(cx, cy, baseX, hy, colors.white, 4);

  dot(cx, cy, 6, "#fff");
  dot(baseX, hy, 6, "#fff");

  angleArc(cx, cy, ang, 26);

  if(flags.labels){
    label((cx+baseX)/2, cy+18, "Ground (Adj)", colors.cos);
    label(baseX+62, (cy+hy)/2, "Height (Opp)", colors.sin);
    label((cx+baseX)/2+20, (cy+hy)/2-12, "Line of sight (Hyp)", "#fff");
  }
  if(state.readout){
    const s = Math.sin(ang), c = Math.cos(ang), t = s/c;
    label(cx+78, cy-46, `tan θ = ${fmt(t)}`, colors.tan);
  }
}

/* =========================================================
   Drawing primitives
   ========================================================= */
function neon(x1,y1,x2,y2,color,width=3){
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
  ctx.lineWidth = width*4;
  ctx.strokeStyle = color;
  ctx.globalAlpha = 0.22;
  ctx.stroke();
  ctx.lineWidth = width;
  ctx.globalAlpha = 1;
  ctx.strokeStyle = color;
  ctx.stroke();
}
function dot(x,y,r,color){
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
}
function label(x,y,text,color){
  ctx.save();
  ctx.font = "950 12px Segoe UI, system-ui, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  const pad=6;
  const w = ctx.measureText(text).width + pad*2;
  ctx.fillStyle = "rgba(0,0,0,0.72)";
  ctx.fillRect(x-w/2, y-10, w, 20);
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.strokeRect(x-w/2, y-10, w, 20);
  ctx.fillStyle = color;
  ctx.fillText(text, x, y);
  ctx.restore();
}
function rightAngle(x,y,size){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.55)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x - size, y);
  ctx.lineTo(x - size, y - size);
  ctx.lineTo(x, y - size);
  ctx.stroke();
  ctx.restore();
}
function angleArc(cx, cy, ang, r){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.6)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  // draw from 0 to ang
  ctx.arc(cx, cy, r, 0, -ang, true);
  ctx.stroke();
  ctx.restore();
}
function laser(x1,y1,x2,y2){
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(255,255,255,0.9)";
  ctx.setLineDash([6,6]);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.lineWidth = 10;
  ctx.strokeStyle = "rgba(255,255,255,0.14)";
  ctx.stroke();
  ctx.restore();
  dot(x2,y2,4,"#fff");
}
function roundRect(x, y, w, h, r, fill, stroke){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* =========================================================
   Boot
   ========================================================= */
buildNav();
setLesson(0);
setTimeout(resize, 20);
resize();
</script>

</body>
</html>
