<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trig Engine v13 (The Architect)</title>
    <style>
        :root {
            --bg: #050505;
            --panel: #0a0a0a;
            --text: #eee;
            --sin: #ff0055;
            --cos: #00ccff;
            --tan: #ffcc00;
            --sec: #ccffff;
            --csc: #ffcccc;
            --cot: #ff8800;
            --root: #4ade80;
        }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        /* STAGE */
        #stage {
            flex: 1;
            min-width: 0;
            position: relative;
            cursor: crosshair;
            background: #000;
            overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; outline: none; }

        /* CONTROLS */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(10,10,10,0.9);
            padding: 8px;
            border-radius: 40px;
            border: 1px solid #333;
            z-index: 20;
            max-width: 95%;
            overflow-x: auto;
            white-space: nowrap;
            scrollbar-width: none; 
        }
        .controls::-webkit-scrollbar { display: none; }

        .btn {
            background: transparent;
            color: #888;
            border: none;
            padding: 8px 16px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            border-radius: 30px;
            font-size: 0.75rem;
            transition: 0.2s;
        }
        .btn:hover { color: #fff; background: rgba(255,255,255,0.1); }
        .btn.active { color: #000; background: #fff; box-shadow: 0 0 15px rgba(255,255,255,0.3); }

        .btn#btn-root.active { background: var(--root); box-shadow: 0 0 15px var(--root); }
        .btn#btn-shadows.active { background: var(--sin); box-shadow: 0 0 15px var(--sin); }
        .btn#btn-walls.active { background: var(--tan); box-shadow: 0 0 15px var(--tan); }
        .btn#btn-ceiling.active { background: var(--cot); box-shadow: 0 0 15px var(--cot); }
        .btn#btn-god.active { background: #fff; box-shadow: 0 0 15px #fff; }
        .btn#btn-sat.active { background: #22c55e; box-shadow: 0 0 15px #22c55e; }
        .btn#btn-real.active { background: #bd00ff; box-shadow: 0 0 15px #bd00ff; }

        /* RIGHT PANEL */
        #panel {
            width: 420px;
            flex-shrink: 0;
            background: var(--panel);
            border-left: 1px solid #222;
            display: flex;
            flex-direction: column;
            z-index: 10;
            position: relative;
        }

        .content { padding: 25px; overflow-y: auto; flex-grow: 1; }
        
        h1 { margin: 0; font-size: 2rem; letter-spacing: -1px; line-height: 1; }
        h2 { margin: 0 0 15px 0; font-size: 0.8rem; color: #666; text-transform: uppercase; letter-spacing: 3px; }
        
        p { line-height: 1.5; color: #bbb; margin-bottom: 1.2em; font-size: 0.95rem; }
        strong { color: #fff; }
        .highlight { background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; color: #fff; font-weight: bold; }

        /* DATA BOX */
        .data-box {
            background: #000;
            padding: 15px 25px;
            border-top: 1px solid #222;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        .row { display: flex; justify-content: space-between; margin-bottom: 6px; align-items: center; }
        .bar-bg { width: 80px; height: 6px; background: #222; border-radius: 3px; overflow: hidden; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.1s; }

        /* PROOF CANVAS */
        #proof-stage {
            width: 100%;
            height: 250px;
            background: #000;
            border-bottom: 1px solid #333;
            display: none; 
        }

        /* SAT OVERLAY */
        #sat-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 30;
            display: none;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        #sat-overlay.active { display: block; }
        
        .sat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .sat-card {
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: 0.2s;
        }
        .sat-card:hover { border-color: #fff; background: rgba(40, 40, 40, 0.95); transform: translateY(-2px); }
        .sat-card.active-proof { border-color: #4ade80; background: rgba(10, 30, 10, 0.95); box-shadow: 0 0 25px rgba(74, 222, 128, 0.2); }
        .sat-card h3 { color: #fff; margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 8px; font-size: 1.1rem;}
        .sat-card .math { font-family: monospace; font-size: 1.2rem; color: #4ade80; background: rgba(74, 222, 128, 0.1); padding: 10px; border-radius: 6px; display: block; text-align: center; margin: 15px 0;}

        @media (max-width: 700px) {
            body { flex-direction: column; }
            #stage { flex: 2; }
            #panel { width: 100%; height: 50%; border-left: none; border-top: 1px solid #222; }
        }
    </style>
</head>
<body>

<div id="stage">
    <canvas id="cvs"></canvas>
    
    <!-- SAT OVERLAY -->
    <div id="sat-overlay">
        <h1 style="text-align:center; margin-bottom:10px;">THE PROOF DECODER</h1>
        <p style="text-align:center; color:#888; margin-bottom:30px;">CLICK a formula to see <strong>WHY</strong> it works.</p>
        
        <div class="sat-grid">
            <div class="sat-card" id="card-pythag" onclick="activateProof('pythag')">
                <h3 style="color:var(--sin)">1. THE CIRCLE</h3>
                <p><strong>Formula:</strong> <span class="math">sin² + cos² = 1</span></p>
                <p style="font-size:0.9rem; color:#aaa">The foundation of everything.</p>
            </div>
            <div class="sat-card" id="card-tan" onclick="activateProof('tan')">
                <h3 style="color:var(--tan)">2. THE WALL</h3>
                <p><strong>Formula:</strong> <span class="math">tan² + 1 = sec²</span></p>
                <p style="font-size:0.9rem; color:#aaa">Proves the link between Wall Height and Beam Length.</p>
            </div>
            <div class="sat-card" id="card-cot" onclick="activateProof('cot')">
                <h3 style="color:var(--cot)">3. THE CEILING</h3>
                <p><strong>Formula:</strong> <span class="math">cot² + 1 = csc²</span></p>
                <p style="font-size:0.9rem; color:#aaa">The inverted version of the wall.</p>
            </div>
            <div class="sat-card" id="card-slope" onclick="activateProof('slope')">
                <h3 style="color:#fff">4. RATIO ID</h3>
                <p><strong>Formula:</strong> <span class="math">tan = sin / cos</span></p>
                <p style="font-size:0.9rem; color:#aaa">Similar triangles scaling up.</p>
            </div>
            <div class="sat-card" id="card-co" onclick="activateProof('co')">
                <h3 style="color:#4ade80">5. THE "CO" TRAP</h3>
                <p><strong>Formula:</strong> <span class="math">sin(x) = cos(90-x)</span></p>
                <p style="font-size:0.9rem; color:#aaa">The #1 SAT Trick Question.</p>
            </div>
        </div>
        
        <div style="text-align:center; margin-top:30px;">
            <button class="btn active" onclick="setMode('shadows')">EXIT PROOF MODE</button>
        </div>
    </div>

    <div class="controls">
        <button class="btn active" id="btn-root" onclick="setMode('root')">0. THE ROOT</button>
        <button class="btn" id="btn-shadows" onclick="setMode('shadows')">1. Shadows</button>
        <button class="btn" id="btn-walls" onclick="setMode('walls')">2. Walls</button>
        <button class="btn" id="btn-ceiling" onclick="setMode('ceiling')">3. Ceiling</button>
        <button class="btn" id="btn-god" onclick="setMode('god')">4. God Mode</button>
        <button class="btn" id="btn-sat" onclick="setMode('sat')">5. PROOF MODE</button>
        <button class="btn" id="btn-real" onclick="setMode('real')">6. REAL WORLD</button>
    </div>
</div>

<div id="panel">
    <!-- Proof Canvas -->
    <canvas id="proof-stage" width="400" height="250"></canvas>

    <div class="content">
        <h1>TRIG<br>VELOCITY</h1>
        <h2>Concept Engine v13.0</h2>
        <div id="txt"></div>
    </div>
    
    <div class="data-box" id="data-display"></div>
</div>

<script>
    // MAIN CANVAS
    const cvs = document.getElementById('cvs');
    const ctx = cvs.getContext('2d', { alpha: false });
    
    // PROOF CANVAS
    const pCvs = document.getElementById('proof-stage');
    const pCtx = pCvs.getContext('2d');

    // CONFIG
    const colors = {
        bg: '#050505',
        sin: '#ff0055',
        cos: '#00ccff',
        tan: '#ffcc00',
        sec: '#ccffff',
        csc: '#ffcccc',
        cot: '#ff8800',
        root: '#4ade80',
        mech: '#bd00ff',
        grid: '#222',
        text: '#fff'
    };

    let state = {
        w: 0, h: 0, cx: 0, cy: 0, scale: 200,
        angle: 0.927, 
        mode: 'root',
        proofTarget: null, 
        dragging: false,
        wavePoints: []
    };

    // SCRIPTS
    const content = {
        root: `
            <p><strong>0. The Root: WHY a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></strong></p>
            <p>Trigonometry doesn't care about the lines. It cares about the <strong>Squares</strong> attached to them.</p>
            
            <p><strong>The Visual Proof:</strong><br>
            The Triangle lives inside the Circle (Radius 1).
            Look at the grid tiles on the screen.</p>
            <p>
            <span style="color:var(--sin)">Pink Square</span> Area: <span id="r-sin">0.64</span><br>
            <span style="color:var(--cos)">Blue Square</span> Area: <span id="r-cos">0.36</span>
            </p>
            <p>If you smash the Blue and Pink tiles together, they fit <strong>perfectly</strong> into the Green Hypotenuse Square.</p>
            
            <p class="highlight" style="text-align:center">Pink Area + Blue Area = 1.00</p>
            <p>This is why we square everything. sin + cos &ne; 1. But sin<sup>2</sup> + cos<sup>2</sup> = 1. Always.</p>
        `,
        shadows: `
            <p><strong>1. SOH CAH TOA vs. The Scanner</strong></p>
            <p>You know <strong>Sin = Opp / Hyp</strong>.</p>
            <p>Look at the canvas. We force the White Arm (Hypotenuse) to equal <strong>1.0</strong>.</p>
            
            <p><strong>The Math:</strong><br>
            Sin = Opp / 1  →  <strong>Sin = Opp</strong><br>
            Cos = Adj / 1  →  <strong>Cos = Adj</strong></p>
            
            <p><strong>The Visual:</strong><br>
            The Blue Light scans down. The <strong>Shadow (Adjacent)</strong> is Cosine.<br>
            The Pink Light scans left. The <strong>Shadow (Opposite)</strong> is Sine.</p>
        `,
        walls: `
            <p><strong>2. The "Zoom" Logic</strong></p>
            <p>Look at the diagram. We have a <strong>Mini Triangle</strong> (Inside) and a <strong>Mega Triangle</strong> (Wall).</p>
            
            <p><strong>The Projector:</strong><br>
            We take the Mini Triangle (Sin, Cos) and blow it up until the base is 1.0.</p>
            
            <p><strong>Calculations:</strong><br>
            To get from Cos &rarr; 1, we divide by Cos.<br>
            So we must divide the Height (Sin) by Cos.</p>
            <p class="highlight" style="text-align:center">Tan = Sin / Cos</p>
        `,
        ceiling: `
            <p><strong>3. The "Ceiling" Logic</strong></p>
            <p>Now we project onto the ceiling. We scale the triangle until the <strong>Height is 1</strong>.</p>
            
            <p><strong>Calculations:</strong><br>
            To get from Sin &rarr; 1, we divide by Sin.<br>
            So we must divide the Base (Cos) by Sin.</p>
            <p class="highlight" style="text-align:center">Cot = Cos / Sin</p>
        `,
        god: `
            <p><strong>4. The Trigonometric Trinity</strong></p>
            <p>The "God Mode" view reveals three distinct families of lines:</p>
            
            <p><strong>1. The Chords (Inside):</strong><br>
            <span style="color:var(--sin)">Sin</span> and <span style="color:var(--cos)">Cos</span>. They are trapped inside the circle. They measure x/y position.</p>
            
            <p><strong>2. The Tangents (Touching):</strong><br>
            <span style="color:var(--tan)">Tan</span> and <span style="color:var(--cot)">Cot</span>. They touch the edge. They represent the "Slope" of the angle.</p>
            
            <p><strong>3. The Secants (Cutting):</strong><br>
            <span style="color:var(--sec)">Sec</span> and <span style="color:var(--csc)">Csc</span>. They slice through the center. They represent the distance to the "walls".</p>
            
            <p><em>They are all measuring the exact same angle, just using different rulers.</em></p>
        `,
        sat: `
            <p><strong>5. The Proof Decoder</strong></p>
            <p>Select a formula on the left.</p>
            <p>The visual proof will appear <strong>RIGHT HERE</strong> in this panel.</p>
        `,
        real: `
            <p><strong>6. The Industrial Application</strong></p>
            <p><strong>1. Mechanical Engineering (Pistons):</strong><br>
            A car engine turns a Circle (Crankshaft) into a Line (Piston).<br>
            The Height of the piston is literally the <strong>Sine</strong> of the wheel angle.</p>
            
            <p><strong>2. Civil Engineering (Bridges):</strong><br>
            Look at the Arm as a bridge cable.<br>
            <span style="color:var(--sin)">SIN</span> = Lifting Force (Vertical).<br>
            <span style="color:var(--cos)">COS</span> = Crushing Force (Horizontal).</p>
            
            <p><strong>3. Surveying (Tangents):</strong><br>
            To measure a mountain, you measure distance to the base (1) and look up.<br>
            <span style="color:var(--tan)">TAN</span> * Distance = Height.</p>
        `,
        // PROOF TEXTS
        proof_pythag: `
            <h3 style="color:var(--sin)">1. THE CIRCLE PROOF</h3>
            <p><strong>Setup:</strong> Right Triangle inside circle.</p>
            <ul>
                <li>Base = <strong style="color:var(--cos)">cos</strong></li>
                <li>Height = <strong style="color:var(--sin)">sin</strong></li>
                <li>Hyp = <strong style="color:#fff">1</strong></li>
            </ul>
            <p>Apply Pythagoras (a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>):</p>
            <p class="highlight" style="text-align:center">sin<sup>2</sup> + cos<sup>2</sup> = 1</p>
        `,
        proof_tan: `
            <h3 style="color:var(--tan)">2. THE WALL PROOF</h3>
            <p><strong>Setup:</strong> The Big Triangle hitting the wall.</p>
            <ul>
                <li>Base = <strong style="color:#fff">1</strong></li>
                <li>Height = <strong style="color:var(--tan)">tan</strong></li>
                <li>Hyp = <strong style="color:var(--sec)">sec</strong></li>
            </ul>
            <p>Apply Pythagoras:</p>
            <p class="highlight" style="text-align:center">1 + tan<sup>2</sup> = sec<sup>2</sup></p>
        `,
        proof_cot: `
            <h3 style="color:var(--cot)">3. THE CEILING PROOF</h3>
            <p><strong>Setup:</strong> The Triangle hitting the ceiling.</p>
            <ul>
                <li>Height = <strong style="color:#fff">1</strong></li>
                <li>Base = <strong style="color:var(--cot)">cot</strong></li>
                <li>Hyp = <strong style="color:var(--csc)">csc</strong></li>
            </ul>
            <p>Apply Pythagoras:</p>
            <p class="highlight" style="text-align:center">cot<sup>2</sup> + 1 = csc<sup>2</sup></p>
        `,
        proof_slope: `
            <h3 style="color:#fff">4. THE RATIO PROOF</h3>
            <p><strong>Setup:</strong> Similar Triangles.</p>
            <p>The Inner Triangle (Blue) and Outer Triangle (Yellow) share the same angle.</p>
            <p>Ratios must be equal:</p>
            <p class="highlight" style="text-align:center">sin / cos = tan / 1</p>
        `,
        proof_co: `
            <h3 style="color:#4ade80">5. THE CO-FUNCTION PROOF</h3>
            <p><strong>Setup:</strong> Look at the triangle.</p>
            <p>Angle A = <strong style="color:#fff">x</strong>.<br>
            Angle B = <strong style="color:#fff">90 - x</strong>.</p>
            <p>The side <strong>Opposite</strong> to A is the side <strong>Adjacent</strong> to B.</p>
            <p class="highlight" style="text-align:center">sin(x) = cos(90-x)</p>
        `
    };

    // INIT
    function resize() {
        if(!cvs || !cvs.parentElement) return;
        const p = cvs.parentElement;
        state.w = p.clientWidth;
        state.h = p.clientHeight;
        if(state.w === 0 || state.h === 0) return;

        cvs.width = state.w;
        cvs.height = state.h;
        state.cx = state.w * 0.35;
        state.cy = state.h * 0.65;
        state.scale = Math.min(state.w, state.h) * 0.28;
        draw();
    }
    window.addEventListener('resize', resize);
    window.addEventListener('load', resize);

    // INPUT
    function interact(x, y) {
        if(state.w === 0) return;
        const dx = x - state.cx;
        const dy = y - state.cy;
        let ang = Math.atan2(-dy, dx);
        if(ang < 0.05) ang = 0.05;
        if(ang > 1.52 && state.mode !== 'real') ang = 1.52;
        state.angle = ang;
        draw();
        updateUI();
    }

    cvs.addEventListener('mousedown', e => { state.dragging = true; interact(e.offsetX, e.offsetY); });
    window.addEventListener('mousemove', e => { 
        if(state.dragging) {
            const rect = cvs.getBoundingClientRect();
            interact(e.clientX - rect.left, e.clientY - rect.top);
        }
    });
    window.addEventListener('mouseup', () => state.dragging = false);
    
    cvs.addEventListener('touchstart', e => { 
        e.preventDefault(); 
        state.dragging = true;
        const rect = cvs.getBoundingClientRect();
        interact(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
    }, {passive:false});
    cvs.addEventListener('touchmove', e => {
        e.preventDefault();
        if(state.dragging) {
            const rect = cvs.getBoundingClientRect();
            interact(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
        }
    }, {passive:false});

    // LOGIC
    function setMode(m) {
        state.mode = m;
        document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById('btn-'+m);
        if(btn) btn.classList.add('active');
        
        document.getElementById('proof-stage').style.display = 'none';
        
        const txt = document.getElementById('txt');
        if(txt && content[m]) txt.innerHTML = content[m];
        
        const satOverlay = document.getElementById('sat-overlay');
        if(satOverlay) {
            if(m === 'sat') satOverlay.classList.add('active');
            else satOverlay.classList.remove('active');
        }

        if(m === 'real') {
            requestAnimationFrame(animatePiston);
        }

        updateUI(); 
        draw();
    }

    function animatePiston() {
        if(state.mode !== 'real') return;
        state.angle += 0.02; 
        draw();
        updateUI();
        requestAnimationFrame(animatePiston);
    }

    function activateProof(target) {
        state.proofTarget = target;
        document.querySelectorAll('.sat-card').forEach(c => c.classList.remove('active-proof'));
        document.getElementById('card-'+target).classList.add('active-proof');
        
        const txt = document.getElementById('txt');
        if(txt && content['proof_'+target]) txt.innerHTML = content['proof_'+target];
        
        document.getElementById('proof-stage').style.display = 'block';
        drawProof(target);
    }
    window.activateProof = activateProof;

    function updateUI() {
        const box = document.getElementById('data-display');
        if(!box) return;

        const c = Math.cos(state.angle);
        const s = Math.sin(state.angle);
        const t = Math.tan(state.angle);
        const deg = ((state.angle * 180 / Math.PI) % 360).toFixed(0);

        let html = '';
        
        if (state.mode === 'root' || state.mode === 'shadows' || state.mode === 'god' || state.mode === 'sat') {
            html += createRow('COS', c, colors.cos);
            html += createRow('SIN', s, colors.sin);
        }
        if (state.mode === 'walls' || state.mode === 'god' || state.mode === 'sat') {
            html += createRow('TAN', t, colors.tan);
        }
        if (state.mode === 'real') {
             html += createRow('PISTON', s, colors.mech);
        }
        
        html += `<div style="border-top:1px solid #333; margin:10px 0"></div>
                 <div class="row"><span>ANGLE</span><strong style="color:#fff; font-size:1.2rem;">${deg}°</strong></div>`;
        
        box.innerHTML = html;
        
        // Update Root Content if needed
        if(state.mode === 'root') {
            const rSin = document.getElementById('r-sin');
            const rCos = document.getElementById('r-cos');
            if(rSin) rSin.innerText = (s*s).toFixed(2);
            if(rCos) rCos.innerText = (c*c).toFixed(2);
        }
    }

    function createRow(label, val, color) {
        let pct = Math.abs(Math.min(val, 2)) * 50; 
        let valStr = (Math.abs(val) > 10) ? "∞" : val.toFixed(2);
        return `
        <div class="row" style="color:${color}">
            <span>${label}</span>
            <div style="display:flex; align-items:center; gap:10px;">
                <span>${valStr}</span>
                <div class="bar-bg"><div class="bar-fill" style="width:${pct}%; background:${color}"></div></div>
            </div>
        </div>`;
    }

    // --- MAIN RENDERER ---
    function draw() {
        if(state.w === 0 || state.h === 0) return;

        const { w, h, cx, cy, scale, angle, mode } = state;
        const tx = cx + scale * Math.cos(angle); 
        const ty = cy - scale * Math.sin(angle); 
        
        const wallX = cx + scale;
        const tanY = cy - scale * Math.tan(angle);
        const ceilY = cy - scale;
        const cotX = cx + scale * (1 / Math.tan(angle));

        ctx.fillStyle = colors.bg;
        ctx.fillRect(0, 0, w, h);

        if(mode !== 'real' && mode !== 'root') drawRuler(cx, cy, scale, w, h);

        // --- ROOT (PYTHAGORAS REIMAGINED) ---
        if (mode === 'root') {
            const size = scale; 
            const rTx = cx + size * Math.cos(angle);
            const rTy = cy - size * Math.sin(angle);
            
            // Draw Circle
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(cx, cy, size, 0, Math.PI*2); ctx.stroke();

            // Draw Triangle Base
            drawNeon(cx, cy, rTx, cy, colors.cos, 3);
            drawNeon(rTx, cy, rTx, rTy, colors.sin, 3);
            drawNeon(cx, cy, rTx, rTy, "#fff", 3);

            // 1. COS SQUARE (Horizontal)
            const cosLen = rTx - cx;
            const cosSize = Math.abs(cosLen);
            ctx.fillStyle = "rgba(0, 204, 255, 0.2)";
            ctx.strokeStyle = "rgba(0, 204, 255, 0.5)";
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.rect(cx, cy, cosLen, cosSize); 
            ctx.fill();
            ctx.stroke();
            
            ctx.beginPath();
            for(let i=0.1; i<1.0; i+=0.2) {
                ctx.moveTo(cx + cosLen*i, cy);
                ctx.lineTo(cx + cosLen*i, cy + cosSize);
                ctx.moveTo(cx, cy + cosSize*i);
                ctx.lineTo(cx + cosLen, cy + cosSize*i);
            }
            ctx.stroke();
            
            // 2. SIN SQUARE (Vertical)
            const sinLen = cy - rTy;
            const sinSize = Math.abs(sinLen);
            ctx.fillStyle = "rgba(255, 0, 85, 0.2)";
            ctx.strokeStyle = "rgba(255, 0, 85, 0.5)";
            
            ctx.beginPath();
            ctx.rect(rTx, cy, sinSize, -sinLen);
            ctx.fill();
            ctx.stroke();
            
            ctx.beginPath();
            for(let i=0.1; i<1.0; i+=0.2) {
                ctx.moveTo(rTx + sinSize*i, cy);
                ctx.lineTo(rTx + sinSize*i, cy - sinLen);
                ctx.moveTo(rTx, cy - sinLen*i);
                ctx.lineTo(rTx + sinSize, cy - sinLen*i);
            }
            ctx.stroke();

            // 3. HYP SQUARE (Angled)
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(-angle);
            ctx.fillStyle = "rgba(74, 222, 128, 0.1)";
            ctx.strokeStyle = "rgba(74, 222, 128, 0.5)";
            ctx.beginPath();
            ctx.rect(0, -size, size, size); 
            ctx.fill();
            ctx.stroke();
            
            ctx.beginPath();
            for(let i=0.2; i<1.0; i+=0.2) {
                ctx.moveTo(size*i, -size); ctx.lineTo(size*i, 0);
                ctx.moveTo(0, -size*i); ctx.lineTo(size, -size*i);
            }
            ctx.stroke();
            ctx.restore();
            
            // Labels
            drawLabel(cx + cosLen/2, cy + cosSize/2, (Math.cos(angle)**2).toFixed(2), "#fff");
            drawLabel(rTx + sinSize/2, cy - sinLen/2, (Math.sin(angle)**2).toFixed(2), "#fff");
            
            return;
        }

        // MAIN CIRCLE 
        if(mode !== 'real') {
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(cx, cy, scale, 0, Math.PI*2); ctx.stroke();
        }

        // --- SHADOWS ---
        if (mode === 'shadows' || mode === 'god') {
            ctx.save();
            ctx.globalCompositeOperation = 'screen'; 
            
            // Floor Beam
            const lightY = cy - scale * 1.5;
            const gradCos = ctx.createLinearGradient(tx, lightY, tx, cy);
            gradCos.addColorStop(0, "rgba(0, 204, 255, 0.4)"); 
            gradCos.addColorStop(1, "rgba(0, 204, 255, 0.0)"); 
            ctx.fillStyle = gradCos;
            ctx.beginPath(); ctx.moveTo(tx-20, lightY); ctx.lineTo(tx+20, lightY); ctx.lineTo(tx, cy); ctx.fill();

            // Wall Beam
            const lightX = cx + scale * 1.5;
            const gradSin = ctx.createLinearGradient(lightX, ty, cx, ty);
            gradSin.addColorStop(0, "rgba(255, 0, 85, 0.4)"); 
            gradSin.addColorStop(1, "rgba(255, 0, 85, 0.0)"); 
            ctx.fillStyle = gradSin;
            ctx.beginPath(); ctx.moveTo(lightX, ty-20); ctx.lineTo(lightX, ty+20); ctx.lineTo(cx, ty); ctx.fill();
            
            ctx.restore();

            drawNeon(cx, cy, tx, cy, colors.cos, 4); 
            drawNeon(cx, cy, cx, ty, colors.sin, 4); 
            drawDashed(tx, ty, tx, cy, colors.cos);
            drawDashed(tx, ty, cx, ty, colors.sin);
            
            drawLabel(cx + (tx-cx)/2, cy + 25, "cos", colors.cos);
            drawLabel(cx - 35, cy + (ty-cy)/2, "sin", colors.sin);
        }

        // --- WALLS ---
        if (mode === 'walls' || mode === 'god') {
            ctx.strokeStyle = "#444"; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(wallX, cy+50); ctx.lineTo(wallX, cy-h); ctx.stroke();
            
            // MINI TRIANGLE LABELS (SIN/COS)
            drawNeon(cx, cy, tx, cy, colors.cos, 2);
            drawNeon(tx, cy, tx, ty, colors.sin, 2);
            drawLabel((cx+tx)/2, cy+15, "cos", "#666");
            drawLabel(tx-20, (cy+ty)/2, "sin", "#666");

            // MEGA TRIANGLE
            drawNeon(wallX, cy, wallX, tanY, colors.tan, 4);
            
            if (mode !== 'god') {
                drawLaser(cx, cy, wallX, tanY); 
                drawLabel(wallX + 35, (cy+tanY)/2, "TAN", colors.tan);
                drawLabel((cx+wallX)/2, (cy+tanY)/2 - 20, "SEC", colors.sec);
            }
        }

        // --- CEILING ---
        if (mode === 'ceiling' || mode === 'god') {
            ctx.strokeStyle = "#444"; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(cx-50, ceilY); ctx.lineTo(w, ceilY); ctx.stroke();
            
            // MINI TRIANGLE LABELS
            drawNeon(cx, cy, cx, ty, colors.sin, 2);
            drawNeon(cx, ty, tx, ty, colors.cos, 2);
            drawLabel(cx-20, (cy+ty)/2, "sin", "#666");
            drawLabel((cx+tx)/2, ty+15, "cos", "#666");

            // MEGA TRIANGLE
            drawNeon(cx, ceilY, cotX, ceilY, colors.cot, 4);
            
            if (mode !== 'god') {
                drawLaser(cx, cy, cotX, ceilY);
                drawLabel((cx+cotX)/2, ceilY - 25, "COT", colors.cot);
                drawLabel((cx+cotX)/2, (cy+ceilY)/2 + 20, "CSC", colors.csc);
            }
        }

        // --- REAL WORLD (PISTON) ---
        if (mode === 'real') {
            const pistonX = cx + scale * 2;
            const pistonY = ty; 
            
            ctx.strokeStyle = "#333"; ctx.lineWidth=2;
            ctx.beginPath(); ctx.arc(cx, cy, scale, 0, Math.PI*2); ctx.stroke();
            drawNeon(cx, cy, tx, ty, "#fff", 4);
            drawNeon(tx, ty, pistonX, pistonY, "#666", 3);
            ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(tx, ty, 6, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(pistonX, pistonY, 6, 0, Math.PI*2); ctx.fill();

            ctx.fillStyle = "rgba(30,30,30,0.8)";
            ctx.fillRect(pistonX - 30, cy - scale - 20, 60, scale*2 + 40);
            ctx.strokeStyle = "#555"; ctx.lineWidth = 2;
            ctx.strokeRect(pistonX - 30, cy - scale - 20, 60, scale*2 + 40);

            ctx.fillStyle = colors.mech;
            ctx.fillRect(pistonX - 25, pistonY - 15, 50, 30);
            drawLabel(pistonX, pistonY - 30, "PISTON (SIN)", colors.mech);
            drawDashed(cx, cy, pistonX, cy, "#444");
        } else {
            drawNeon(cx, cy, tx, ty, "#fff", 3);
            ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(tx, ty, 6, 0, Math.PI*2); ctx.fill();
            if(mode === 'shadows' || mode === 'god') drawLabel((cx+tx)/2, (cy+ty)/2 - 15, "Hyp (1)", "#fff");
        }
    }

    // --- PROOF RENDERER (RIGHT PANEL) ---
    function drawProof(target) {
        const w = pCvs.width;
        const h = pCvs.height;
        const cx = 50;
        const cy = h - 50;
        const s = 150; 
        const a = 0.7; 

        pCtx.fillStyle = "#111";
        pCtx.fillRect(0,0,w,h);
        
        const tx = cx + s * Math.cos(a);
        const ty = cy - s * Math.sin(a);
        const wallX = cx + s;
        const tanY = cy - s * Math.tan(a);
        const ceilY = cy - s;
        const cotX = cx + s * (1/Math.tan(a));

        if(target === 'pythag') {
            pDrawLine(cx, cy, tx, cy, colors.cos, 4); 
            pDrawLine(tx, cy, tx, ty, colors.sin, 4); 
            pDrawLine(cx, cy, tx, ty, "#fff", 4);     
            pLabel("cos", (cx+tx)/2, cy+20, colors.cos);
            pLabel("sin", tx+20, (cy+ty)/2, colors.sin);
            pLabel("1", (cx+tx)/2 - 10, (cy+ty)/2 - 10, "#fff");
        }

        if(target === 'tan') {
            pDrawLine(cx, cy, wallX, cy, "#fff", 4);     
            pDrawLine(wallX, cy, wallX, tanY, colors.tan, 4); 
            pDrawLine(cx, cy, wallX, tanY, colors.sec, 4); 
            pLabel("1", (cx+wallX)/2, cy+20, "#fff");
            pLabel("tan", wallX+25, (cy+tanY)/2, colors.tan);
            pLabel("sec", (cx+wallX)/2 - 10, (cy+tanY)/2 - 10, colors.sec);
        }

        if(target === 'cot') {
            pDrawLine(cx, cy, cx, ceilY, "#fff", 4); 
            pDrawLine(cx, ceilY, cotX, ceilY, colors.cot, 4); 
            pDrawLine(cx, cy, cotX, ceilY, colors.csc, 4); 
            pLabel("1", cx-20, (cy+ceilY)/2, "#fff");
            pLabel("cot", (cx+cotX)/2, ceilY-20, colors.cot);
            pLabel("csc", (cx+cotX)/2 + 10, (cy+ceilY)/2 + 10, colors.csc);
        }

        if(target === 'slope') {
            pCtx.fillStyle = "rgba(0, 204, 255, 0.2)";
            pCtx.beginPath(); pCtx.moveTo(cx, cy); pCtx.lineTo(tx, cy); pCtx.lineTo(tx, ty); pCtx.fill();
            pDrawLine(cx, cy, tx, cy, colors.cos, 2);
            pDrawLine(tx, cy, tx, ty, colors.sin, 2);
            pDrawLine(wallX, cy, wallX, tanY, colors.tan, 4);
            pDrawLine(cx, cy, wallX, tanY, colors.sec, 1);
            pDrawLine(cx, cy, wallX, cy, "#fff", 1);
            pLabel("sin", tx-15, (cy+ty)/2, colors.sin);
            pLabel("cos", (cx+tx)/2, cy-10, colors.cos);
            pLabel("tan", wallX+20, (cy+tanY)/2, colors.tan);
            pLabel("1", (cx+wallX)/2, cy+20, "#fff");
        }

        if(target === 'co') {
            pDrawLine(cx, cy, tx, cy, colors.cos, 4);
            pDrawLine(tx, cy, tx, ty, colors.sin, 4);
            pDrawLine(cx, cy, tx, ty, "#fff", 4);
            pLabel("x", cx+20, cy-10, "#fff");
            pLabel("90-x", tx-10, ty+20, "#fff");
            pLabel("Opp to x", tx+30, (cy+ty)/2, colors.sin);
            pLabel("Adj to 90-x", tx+35, (cy+ty)/2 + 20, colors.sin);
        }
    }

    function pDrawLine(x1, y1, x2, y2, color, w) {
        pCtx.strokeStyle = color;
        pCtx.lineWidth = w;
        pCtx.beginPath(); pCtx.moveTo(x1,y1); pCtx.lineTo(x2,y2); pCtx.stroke();
    }
    function pLabel(t, x, y, c) {
        pCtx.fillStyle = c;
        pCtx.font = "bold 14px sans-serif";
        pCtx.textAlign = "center";
        pCtx.textBaseline = "middle";
        pCtx.fillText(t, x, y);
    }

    function drawRuler(cx, cy, scale, w, h) {
        ctx.strokeStyle = "#222"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke(); 
        ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke();
        
        ctx.fillStyle = "#444"; ctx.font = "10px monospace"; ctx.textAlign = "center";
        for(let i=0.2; i<=1.0; i+=0.2) {
            let px = cx + scale * i;
            ctx.fillRect(px, cy-4, 1, 8);
            ctx.fillText(i.toFixed(1), px, cy + 18);
            let py = cy - scale * i;
            ctx.fillRect(cx-4, py, 8, 1);
            ctx.fillText(i.toFixed(1), cx - 20, py + 3);
        }
    }

    function drawNeon(x1, y1, x2, y2, color, width=2) {
        ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
        ctx.lineWidth = width * 4;
        ctx.strokeStyle = color;
        ctx.globalAlpha = 0.3;
        ctx.stroke();
        ctx.lineWidth = width;
        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = (color === '#fff') ? '#fff' : color; 
        ctx.stroke();
    }

    function drawDashed(x1, y1, x2, y2, color) {
        ctx.save();
        ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
        ctx.strokeStyle = color;
        ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.restore();
    }

    function drawLaser(x1, y1, x2, y2) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.lineWidth = 8;
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.setLineDash([]);
        ctx.stroke();
        ctx.restore();
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.arc(x2, y2, 4, 0, Math.PI*2); ctx.fill();
    }

    function drawLabel(x, y, txt, color) {
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        const w = ctx.measureText(txt).width + 10;
        ctx.fillRect(x - w/2, y - 10, w, 20);
        ctx.fillStyle = color;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "bold 12px sans-serif";
        ctx.fillText(txt, x, y);
    }

    setMode('root');
    setTimeout(resize, 50);
    resize();

</script>
</body>
</html>
