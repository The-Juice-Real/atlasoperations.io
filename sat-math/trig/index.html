<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>SAT Trig — Teach First, Simulate Second (v2.1)</title>
  <style>
    :root{
      --bg:#050505; --panel:#0a0a0a; --text:#eee; --muted:#8a8a8a;
      --sin:#ff0055; --cos:#00ccff; --tan:#ffcc00;
      --sec:#ccffff; --csc:#ffcccc; --cot:#ff8800;
      --ok:#22c55e; --bad:#ef4444; --vio:#bd00ff;
      --grid:#222; --line:#2a2a2a;
    }
    *{box-sizing:border-box}
    body{
      margin:0; height:100vh; width:100vw;
      background:var(--bg); color:var(--text);
      font-family: "Segoe UI", system-ui, sans-serif;
      display:flex; overflow:hidden;
    }

    /* LEFT STAGE */
    #stage{
      flex:1; min-width:0; position:relative; background:#000; overflow:hidden;
      cursor:crosshair;
    }
    canvas{display:block; width:100%; height:100%}

    /* HUD */
    #hud{
      position:absolute; top:14px; left:14px; z-index:20;
      background:rgba(10,10,10,.82);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 12px;
      display:flex; gap:10px; align-items:flex-start;
      backdrop-filter: blur(6px);
      max-width: 92%;
    }
    #hud .k{font-size:.72rem; letter-spacing:1.5px; text-transform:uppercase; color:#777}
    #hud .v{font-weight:950; font-size:1.02rem; line-height:1.2}
    #hud .s{font-size:.85rem; color:#aaa; margin-top:2px}
    .pill{
      padding:6px 10px; border-radius:999px;
      border:1px solid #333; background:rgba(255,255,255,.05);
      color:#ddd; font-weight:900; font-size:.72rem;
      user-select:none;
      white-space:nowrap;
    }
    .pill.ok{border-color:rgba(34,197,94,.45); color:#c7f9d6}
    .pill.bad{border-color:rgba(239,68,68,.45); color:#ffd1d1}

    /* Micro toggles */
    #microbar{
      position:absolute; top:14px; right:14px; z-index:20;
      background:rgba(10,10,10,.82);
      border:1px solid var(--line);
      border-radius:12px;
      padding:8px 10px;
      display:flex; gap:8px; align-items:center;
      backdrop-filter: blur(6px);
    }
    #microbar button{
      border:none; cursor:pointer;
      padding:8px 10px; border-radius:10px;
      background:rgba(255,255,255,.06);
      color:#ddd; font-weight:950; font-size:.75rem;
    }
    #microbar button.active{
      background:#fff; color:#000;
    }

    /* BOTTOM NAV */
    #nav{
      position:absolute; bottom:16px; left:50%; transform:translateX(-50%);
      z-index:20; display:flex; gap:8px;
      background:rgba(10,10,10,.90);
      border:1px solid #333;
      border-radius:16px;
      padding:10px;
      max-width:95%;
      overflow-x:auto; white-space:nowrap; scrollbar-width:none;
    }
    #nav::-webkit-scrollbar{display:none}
    #nav button{
      border:none; cursor:pointer;
      padding:9px 12px; border-radius:12px;
      background:transparent; color:#888;
      font-weight:950; letter-spacing:.4px; text-transform:uppercase;
      font-size:.72rem;
      transition:.15s;
    }
    #nav button:hover{color:#fff; background:rgba(255,255,255,.08)}
    #nav button.active{background:#fff; color:#000}

    /* RIGHT PANEL */
    #panel{
      width:470px; flex-shrink:0;
      background:var(--panel);
      border-left:1px solid #222;
      display:flex; flex-direction:column;
      position:relative;
    }
    #panelTop{
      padding:18px 18px 12px 18px;
      border-bottom:1px solid #1f1f1f;
    }
    #title{
      margin:0; font-size:1.45rem; letter-spacing:-.5px; line-height:1.15;
      font-weight:980;
    }
    #subtitle{
      margin:8px 0 0 0;
      color:#8f8f8f; font-size:.92rem; line-height:1.35;
    }

    #layers{
      margin-top:12px;
      display:grid; grid-template-columns:repeat(4,1fr); gap:8px;
    }
    #layers button{
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:10px 8px;
      background:#070707;
      color:#bbb;
      font-weight:980;
      font-size:.72rem;
      letter-spacing:1.4px;
      text-transform:uppercase;
      cursor:pointer;
    }
    #layers button.active{
      background:#fff; color:#000; border-color:#fff;
    }
    #layers button.locked{
      opacity:.35; cursor:not-allowed;
    }

    #body{
      padding:16px 18px 18px 18px;
      overflow:auto;
      flex:1;
    }
    p{margin:0 0 12px 0; color:#c0c0c0; line-height:1.62; font-size:.95rem}
    strong{color:#fff}
    ul{margin:0 0 12px 18px; color:#c0c0c0}
    li{margin:6px 0}
    .box{
      border:1px solid #2b2b2b;
      background:rgba(255,255,255,.05);
      border-radius:14px;
      padding:12px 12px;
      margin:12px 0;
    }
    .box.ok{border-color:rgba(34,197,94,.35); background:rgba(34,197,94,.07)}
    .box.bad{border-color:rgba(239,68,68,.35); background:rgba(239,68,68,.07)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace}
    .tag{
      display:inline-block; padding:2px 8px; border-radius:999px;
      background:rgba(255,255,255,.07); border:1px solid #2b2b2b;
      color:#ddd; font-weight:950; font-size:.74rem; letter-spacing:.4px;
    }
    .sat{
      border:1px solid #2b2b2b;
      background:#060606;
      border-radius:14px;
      padding:12px;
    }
    .sat .q{ color:#e8e8e8; font-weight:980; margin-bottom:8px; }
    .sat .a{ color:#bdbdbd; font-size:.92rem; line-height:1.55; }
    .sat .map{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #232323;
      background:rgba(255,255,255,.04);
      color:#cfcfcf;
    }

    #panelBottom{
      padding:12px 18px;
      border-top:1px solid #1f1f1f;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    #panelBottom .left, #panelBottom .right{display:flex; gap:10px}
    #panelBottom button{
      border:none; cursor:pointer;
      padding:10px 12px; border-radius:12px;
      background:rgba(255,255,255,.08); color:#ddd; font-weight:980;
    }
    #panelBottom button.primary{ background:#fff; color:#000; }
    #panelBottom button:disabled{ opacity:.35; cursor:not-allowed; }

    /* QUIZ OVERLAY */
    #quizOverlay{
      position:absolute; inset:0;
      background:rgba(0,0,0,0.88);
      display:none;
      z-index:999;
      padding:18px;
    }
    #quizOverlay.active{display:flex; align-items:center; justify-content:center;}
    #quizCard{
      width:100%;
      max-width:420px;
      border-radius:16px;
      border:1px solid #2b2b2b;
      background:rgba(10,10,10,0.94);
      box-shadow: 0 0 40px rgba(0,0,0,0.55);
      padding:14px;
    }
    #quizTop{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; margin-bottom:10px;
    }
    #quizTitle{
      font-weight:1000; letter-spacing:1.2px;
      text-transform:uppercase; font-size:.78rem;
      color:#ddd;
    }
    #quizTime{
      font-weight:1000; font-size:.82rem; color:#fff;
      padding:6px 10px; border-radius:999px;
      border:1px solid #2b2b2b;
      background:rgba(255,255,255,0.06);
      min-width:74px;
      text-align:center;
    }
    #quizBarWrap{
      flex:1;
      height:10px;
      border-radius:999px;
      background:#151515;
      border:1px solid #222;
      overflow:hidden;
    }
    #quizBar{
      height:100%;
      width:100%;
      background:rgba(34,197,94,0.85);
      transition: width .08s linear;
    }
    #quizQ{
      margin:10px 0 12px 0;
      font-weight:980;
      color:#f0f0f0;
      line-height:1.35;
      font-size:1.02rem;
    }
    #quizChoices{
      display:grid;
      gap:8px;
      margin-bottom:10px;
    }
    .choice{
      border:1px solid #2b2b2b;
      background:rgba(255,255,255,0.05);
      padding:10px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:950;
      color:#ddd;
      text-align:left;
    }
    .choice:hover{border-color:#fff; background:rgba(255,255,255,0.09)}
    .choice:disabled{opacity:.5; cursor:not-allowed}
    #quizResult{
      min-height:22px;
      font-weight:1000;
      letter-spacing:.2px;
    }
    #quizHint{
      margin-top:10px;
      color:#aaa;
      font-size:.86rem;
      line-height:1.4;
      border-top:1px solid #1f1f1f;
      padding-top:10px;
    }
    .good{color:var(--ok)}
    .bad{color:var(--bad)}

    @media (max-width: 820px){
      body{flex-direction:column}
      #panel{width:100%; height:52%}
      #stage{height:48%}
      #microbar{top:64px}
    }
  </style>
</head>
<body>

<div id="stage">
  <canvas id="cvs"></canvas>

  <div id="hud">
    <div>
      <div class="k">ANGLE</div>
      <div class="v" id="hudTheta">θ = 0° (0)</div>
      <div class="s" id="hudEq">Equivalent: 0°</div>
    </div>
    <div class="pill ok" id="hudQuad">QI</div>
    <div class="pill" id="hudRef">ref 0°</div>
  </div>

  <div id="microbar">
    <button id="btnReadout" class="active" title="Show tiny values on the canvas">READOUT</button>
    <button id="btnSnap" class="" title="Snap θ to SAT special angles">SNAP</button>
  </div>

  <div id="nav"></div>
</div>

<div id="panel">
  <!-- QUIZ OVERLAY -->
  <div id="quizOverlay">
    <div id="quizCard">
      <div id="quizTop">
        <div id="quizTitle">SAT CHECK</div>
        <div id="quizBarWrap"><div id="quizBar"></div></div>
        <div id="quizTime">12.0s</div>
      </div>

      <div id="quizQ"></div>
      <div id="quizChoices"></div>
      <div id="quizResult"></div>

      <div id="quizHint">
        You don’t “read” SAT trig. You execute it.  
        Miss or timeout → you get kicked back one step. Then you earn SAT again.
      </div>
    </div>
  </div>

  <div id="panelTop">
    <h1 id="title"></h1>
    <div id="subtitle"></div>

    <div id="layers">
      <button id="layer0" onclick="setLayer(0)">1 Visual</button>
      <button id="layer1" onclick="setLayer(1)">2 Concept</button>
      <button id="layer2" onclick="setLayer(2)">3 Math</button>
      <button id="layer3" onclick="setLayer(3)">4 SAT</button>
    </div>
  </div>

  <div id="body"></div>

  <div id="panelBottom">
    <div class="left">
      <button id="btnPrev" onclick="prevLesson()">Prev</button>
      <button id="btnNext" onclick="nextLesson()">Next</button>
    </div>
    <div class="right">
      <button id="btnBackLayer" onclick="prevLayer()">Back Step</button>
      <button class="primary" id="btnForwardLayer" onclick="nextLayer()">Next Step</button>
    </div>
  </div>
</div>

<script>
/* =========================================================
   SAT TRIG TEACHING ENGINE (v2.1)
   Adds:
   - Timed SAT micro-question on Layer 4 (SAT)
   - Fail/timeout => kicks back one layer + locks SAT again
   ========================================================= */

const cvs = document.getElementById("cvs");
const ctx = cvs.getContext("2d", {alpha:false});

const colors = {
  bg:"#050505", grid:"#222",
  sin:"#ff0055", cos:"#00ccff", tan:"#ffcc00",
  white:"#fff", muted:"#888", ok:"#22c55e", bad:"#ef4444",
};

const SPECIAL_DEG = [0,30,45,60,90,120,135,150,180,210,225,240,270,300,315,330,360];
const TAU = 2*Math.PI;

const state = {
  w:0,h:0,
  baseCx:0, baseCy:0, baseR:220,
  theta: 0.65,
  dragging:false,
  readout:true,
  snap:false,
  lessonIndex:0,
  layerIndex:0,
  unlockedLayer:0,

  // quiz runtime
  quizActive:false,
  quizEndsAt:0,
  quizDurationMs:12000,
  quizTimer:null,
  uiLocked:false,
};

// lesson SAT-passed tracking
const progress = {}; // progress[lessonId] = { satPassed: true }

/* ---------- helpers ---------- */
function radToDeg(r){ return r*180/Math.PI; }
function degToRad(d){ return d*Math.PI/180; }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function normDeg(d){ let x=d%360; if(x<0) x+=360; if(Math.abs(x-360)<1e-9) x=0; return x; }
function quadrantFromDeg(d0){
  const d = normDeg(d0);
  if(d===0) return "Axis +x";
  if(d===90) return "Axis +y";
  if(d===180) return "Axis -x";
  if(d===270) return "Axis -y";
  if(d>0 && d<90) return "QI";
  if(d>90 && d<180) return "QII";
  if(d>180 && d<270) return "QIII";
  return "QIV";
}
function referenceAngleDeg(d0){
  const d = normDeg(d0);
  if(d>=0 && d<=90) return d;
  if(d>90 && d<180) return 180-d;
  if(d>=180 && d<=270) return d-180;
  if(d>270 && d<360) return 360-d;
  return 0;
}
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b,a%b]; } return a||1; }
function degToPiFrac(deg){
  const d = normDeg(deg);
  if(d===0) return "0";
  if(d===180) return "π";
  if(d===360) return "2π";
  let num = Math.round(d);
  let den = 180;
  const g = gcd(num, den);
  num/=g; den/=g;
  if(den===1) return `${num}π`;
  if(num===1) return `π/${den}`;
  return `${num}π/${den}`;
}
function nearestSpecialDeg(d0){
  const d = normDeg(d0);
  let best=SPECIAL_DEG[0], bestDist=1e9;
  for(const s of SPECIAL_DEG){
    const dist = Math.min(Math.abs(d-s), Math.abs((d+360)-s), Math.abs(d-(s+360)));
    if(dist<bestDist){ bestDist=dist; best=s; }
  }
  return {best, dist:bestDist};
}
function thetaSignedForArc(rad){
  let x = rad % TAU;
  if(x<=-Math.PI) x += TAU;
  if(x> Math.PI) x -= TAU;
  return x;
}
function fmt(x){
  if(!Number.isFinite(x)) return "undef";
  const ax=Math.abs(x);
  if(ax<1e-4) return "0";
  return x.toFixed(3);
}

/* Exact trig for special angles */
const EXACT_Q1 = {
  0:   {sin:"0",      cos:"1",      tan:"0"},
  30:  {sin:"1/2",    cos:"√3/2",   tan:"√3/3"},
  45:  {sin:"√2/2",   cos:"√2/2",   tan:"1"},
  60:  {sin:"√3/2",   cos:"1/2",    tan:"√3"},
  90:  {sin:"1",      cos:"0",      tan:"undef"},
};
function applySign(valStr, sign){
  if(valStr==="0") return "0";
  if(valStr==="undef") return "undef";
  if(sign>=0) return valStr;
  if(valStr.startsWith("-")) return valStr;
  return "-" + valStr;
}
function exactFromDeg(deg){
  const d = normDeg(deg);
  const ref = referenceAngleDeg(d);
  const quad = quadrantFromDeg(d);
  if(d===0)   return {sin:"0", cos:"1", tan:"0"};
  if(d===90)  return {sin:"1", cos:"0", tan:"undef"};
  if(d===180) return {sin:"0", cos:"-1", tan:"0"};
  if(d===270) return {sin:"-1", cos:"0", tan:"undef"};
  if(d===360) return {sin:"0", cos:"1", tan:"0"};

  const base = EXACT_Q1[ref];
  if(!base) return null;

  const sgn = {
    QI:  {sin:+1, cos:+1, tan:+1},
    QII: {sin:+1, cos:-1, tan:-1},
    QIII:{sin:-1, cos:-1, tan:+1},
    QIV: {sin:-1, cos:+1, tan:-1},
  }[quad];

  return {
    sin: applySign(base.sin, sgn.sin),
    cos: applySign(base.cos, sgn.cos),
    tan: (base.tan==="undef") ? "undef" : applySign(base.tan, sgn.tan)
  };
}

/* =========================================================
   Lessons
   ========================================================= */
const lessons = [
  {
    id:"unit",
    nav:"0 Unit Circle",
    title:"Trigonometry is a machine",
    subtitle:"Feed it an angle. It outputs a point. That’s the whole game.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:false, projections:false, labels:false, walls:false, quadrants:false},
        html:`
          <p><strong>Visual rule:</strong> drag. You are steering a point around a circle.</p>
          <div class="box">
            <p>This is not “lines and triangles.” That’s the costume.</p>
            <p>The core is: <strong>rotation</strong>.</p>
            <ul>
              <li>Angle θ = the input.</li>
              <li>Point on the circle = the output.</li>
            </ul>
          </div>
          <p class="tag">If you accept “angle → position,” trig stops being magic.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false},
        html:`
          <p><strong>Concept:</strong> the output is a coordinate pair.</p>
          <div class="box ok">
            <p>Every point has:</p>
            <ul>
              <li><strong>x</strong> = horizontal push (right/left)</li>
              <li><strong>y</strong> = vertical push (up/down)</li>
            </ul>
            <p>Trigonometry is the language for these two numbers while the point rotates.</p>
          </div>
          <p>On the stage:</p>
          <ul>
            <li><span style="color:var(--cos)"><strong>Blue</strong></span> drops to the x-axis.</li>
            <li><span style="color:var(--sin)"><strong>Pink</strong></span> drops to the y-axis.</li>
          </ul>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false},
        html:`
          <p><strong>Math translation:</strong></p>
          <div class="box ok">
            <p class="mono"><strong>(x, y) = (cos θ, sin θ)</strong></p>
            <p>Cos is x. Sin is y. No negotiation.</p>
          </div>
          <div class="box">
            <p><strong>Why the identity exists:</strong> the radius is locked to 1.</p>
            <p>Distance from the origin is always 1. That constraint becomes:</p>
            <p class="mono"><strong>cos²θ + sin²θ = 1</strong></p>
            <p>That’s not a “formula.” It’s conservation.</p>
          </div>
          <div class="box bad">
            <p><strong>SAT trap:</strong> “sin + cos = 1”.</p>
            <p>No. Squares. Because distance uses squares.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              Point P is on the unit circle. If P is <span class="mono">(0.6, 0.8)</span>, what is <span class="mono">sin(θ)</span>?
            </div>
            <div class="map">
              <p><strong>Map:</strong> on unit circle, <span class="mono">x = cosθ</span>, <span class="mono">y = sinθ</span>.</p>
              <p><strong>So:</strong> sin(θ) is just the y-value → <span class="mono">0.8</span>.</p>
              <p><strong>And the identity check:</strong> 0.6² + 0.8² = 1 (it matches). SAT loves this.</p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"soh",
    nav:"1 SOHCAHTOA",
    title:"SOHCAHTOA is not a chant. It’s a selector switch.",
    subtitle:"You pick the ratio that uses what you have and what you need.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:false, labels:false, walls:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <p><strong>Visual:</strong> the triangle is real. The labels are relative.</p>
          <div class="box">
            <p>Three sides. Three names:</p>
            <ul>
              <li><strong>Hyp</strong> = longest side (always)</li>
              <li><strong>Opp</strong> = directly across from θ</li>
              <li><strong>Adj</strong> = touches θ (not the hypotenuse)</li>
            </ul>
          </div>
          <div class="box bad">
            <p><strong>Common failure:</strong> calling “up” the opposite forever.</p>
            <p>Rotate θ and Opp changes. That’s the point.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <p><strong>Concept:</strong> ratios don’t care about size.</p>
          <div class="box ok">
            <p>Make the triangle bigger. Every side grows.</p>
            <p>The ratios stay the same because the <strong>shape</strong> is the same.</p>
            <p>That’s why trig works: it’s geometry that survives scaling.</p>
          </div>
          <p>SOHCAHTOA is a menu of “which two sides are you using?”</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <p><strong>Math:</strong> the definitions.</p>
          <div class="box">
            <p class="mono">sin θ = Opp/Hyp</p>
            <p class="mono">cos θ = Adj/Hyp</p>
            <p class="mono">tan θ = Opp/Adj</p>
          </div>
          <div class="box bad">
            <p><strong>SAT rule:</strong> you do not “choose tan because you like tan.”</p>
            <p>You choose the ratio that contains the side you have and the side you want.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, showOppAdjHyp:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              Opp = 9 and Hyp = 15. What is <span class="mono">sin(θ)</span>?
            </div>
            <div class="map">
              <p><strong>Have:</strong> Opp + Hyp. <strong>Need:</strong> sin.</p>
              <p><strong>Pick:</strong> <span class="mono">sin = Opp/Hyp</span></p>
              <p><strong>Build:</strong> <span class="mono">sin(θ)=9/15=3/5</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"scale",
    nav:"2 Scaling",
    title:"Trig ratios are multipliers",
    subtitle:"Once θ is fixed, sin/cos/tan are conversion rates between lengths.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:false, walls:false, quadrants:false, scaleDemo:true, showOppAdjHyp:true},
        html:`
          <p><strong>Visual:</strong> same θ. bigger triangle. same shape.</p>
          <div class="box">
            <p>This is the move SAT hides in plain sight:</p>
            <p><strong>ratio × known side = unknown side</strong></p>
          </div>
          <p class="tag">You are not “doing trig.” You are converting lengths.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, scaleDemo:true, showOppAdjHyp:true},
        html:`
          <p><strong>Concept:</strong> a fixed angle forces a fixed shape.</p>
          <div class="box ok">
            <p>If θ doesn’t change, the triangle can only scale up/down.</p>
            <p>So sin/cos/tan behave like constants while θ is fixed.</p>
            <p>That’s why these problems feel “algebraic” on SAT.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, scaleDemo:true, showOppAdjHyp:true},
        html:`
          <p><strong>Math patterns SAT expects instantly:</strong></p>
          <div class="box">
            <p class="mono">Opp = Hyp · sin θ</p>
            <p class="mono">Adj = Hyp · cos θ</p>
            <p class="mono">Opp = Adj · tan θ</p>
          </div>
          <div class="box bad">
            <p><strong>Trap:</strong> using a ratio that ignores your given side.</p>
            <p>If you have Hyp, tan is usually the wrong first tool.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, scaleDemo:true, showOppAdjHyp:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              Hyp = 10 and <span class="mono">sin(θ)=0.6</span>. Find Opp.
            </div>
            <div class="map">
              <p><strong>Translate:</strong> <span class="mono">sin = Opp/Hyp</span></p>
              <p><strong>Build:</strong> <span class="mono">0.6 = Opp/10</span></p>
              <p><strong>So:</strong> <span class="mono">Opp = 6</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"special",
    nav:"3 Special Angles",
    title:"Exact trig values: SAT’s time tax",
    subtitle:"You don’t get to be slow here. SNAP exists to hardwire it.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:false, walls:false, quadrants:false, specialMode:true},
        html:`
          <p><strong>Visual:</strong> turn SNAP on. Drag. It locks to SAT angles.</p>
          <div class="box">
            <p>These positions are “privileged” because their triangles are clean.</p>
            <p>30-60-90 and 45-45-90 generate the entire exact-value set.</p>
          </div>
          <p class="tag">If you rely on decimals, SAT owns your time.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, specialMode:true},
        html:`
          <p><strong>Concept:</strong> two triangles, not a hundred.</p>
          <div class="box ok">
            <p><strong>30-60-90:</strong> <span class="mono">1 : √3 : 2</span></p>
            <p><strong>45-45-90:</strong> <span class="mono">1 : 1 : √2</span></p>
            <p>Unit circle means Hyp = 1, so every value becomes a clean fraction/radical.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, specialMode:true},
        html:`
          <p><strong>Math:</strong> Quadrant I anchors (memorize or derive fast):</p>
          <div class="box">
            <p class="mono">sin 30 = 1/2,   cos 30 = √3/2</p>
            <p class="mono">sin 45 = √2/2,  cos 45 = √2/2</p>
            <p class="mono">sin 60 = √3/2,  cos 60 = 1/2</p>
          </div>
          <div class="box bad">
            <p><strong>Discipline:</strong> keep values exact. √ stays √.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, specialMode:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              What is <span class="mono">sin(π/3)</span>?
            </div>
            <div class="map">
              <p><strong>Convert:</strong> <span class="mono">π/3 = 60°</span></p>
              <p><strong>Recall:</strong> <span class="mono">sin 60 = √3/2</span></p>
              <p><strong>Answer:</strong> <span class="mono">√3/2</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"quadrants",
    nav:"4 Quadrants",
    title:"Same reference angle. Different signs.",
    subtitle:"Magnitude comes from Quadrant I. Signs come from where you stand.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:false, walls:false, quadrants:true},
        html:`
          <p><strong>Visual:</strong> move θ into every quadrant. Watch what flips.</p>
          <div class="box">
            <ul>
              <li>Left side means x is negative → cos is negative.</li>
              <li>Down side means y is negative → sin is negative.</li>
            </ul>
          </div>
          <p class="tag">See signs first. Compute second.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:true},
        html:`
          <p><strong>Concept:</strong> reference angle is the “clean acute twin.”</p>
          <div class="box ok">
            <p>Step 1: find the acute angle to the x-axis.</p>
            <p>Step 2: use the exact value from Quadrant I.</p>
            <p>Step 3: flip signs based on quadrant.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:true},
        html:`
          <p><strong>Math sign table (sin, cos, tan):</strong></p>
          <div class="box">
            <p class="mono">QI: + + +</p>
            <p class="mono">QII: + − −</p>
            <p class="mono">QIII: − − +</p>
            <p class="mono">QIV: − + −</p>
          </div>
          <div class="box bad">
            <p><strong>Reality:</strong> right magnitude + wrong sign = 0 points.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              If θ = 210°, what is <span class="mono">cos(θ)</span>?
            </div>
            <div class="map">
              <p><strong>ref:</strong> 210° → 30°</p>
              <p><strong>magnitude:</strong> cos 30 = √3/2</p>
              <p><strong>sign:</strong> 210° is QIII → cos negative</p>
              <p><strong>answer:</strong> <span class="mono">−√3/2</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"tan",
    nav:"5 Tan & Slope",
    title:"Tan is tilt. Slope is tilt. Same idea.",
    subtitle:"SAT will disguise tan as coordinate geometry.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:false, walls:true, quadrants:false},
        html:`
          <p><strong>Visual:</strong> wall is “run = 1.” the rise is tan.</p>
          <div class="box">
            <p>As θ grows, the tilt grows. Tan measures that tilt.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:true, quadrants:false},
        html:`
          <p><strong>Concept:</strong> slope is rise/run.</p>
          <div class="box ok">
            <p>Opp = rise. Adj = run.</p>
            <p>So tan is literally the slope of the angle.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:true, quadrants:false},
        html:`
          <p><strong>Math:</strong></p>
          <div class="box">
            <p class="mono">tan θ = Opp/Adj</p>
            <p class="mono">tan θ = sin θ / cos θ</p>
          </div>
          <div class="box bad">
            <p><strong>Undefined:</strong> when cos = 0 (90°, 270°).</p>
            <p>That’s not a “big number.” It’s not defined.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:true, quadrants:false},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              A line makes an angle θ with the positive x-axis. If slope is 3, what is <span class="mono">tan(θ)</span>?
            </div>
            <div class="map">
              <p><strong>Map:</strong> tan θ = slope</p>
              <p><strong>Answer:</strong> <span class="mono">3</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"co",
    nav:"6 Co-functions",
    title:"The ‘CO’ trick: sin and cos are the same leg, viewed from different angles",
    subtitle:"SAT loves this because it punishes memorization without geometry.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:false, walls:false, quadrants:false, coMode:true},
        html:`
          <p><strong>Visual:</strong> keep the triangle. swap the angle.</p>
          <div class="box">
            <p>In a right triangle, the two acute angles add to 90°.</p>
            <p>If you switch which angle you call θ, opposite/adjacent swap.</p>
          </div>
          <p class="tag">Same triangle. Different viewpoint. That’s the whole trick.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, coMode:true},
        html:`
          <p><strong>Concept:</strong> sin is “vertical-from-this-angle.”</p>
          <div class="box ok">
            <p>If you rotate your viewpoint 90°, what used to be “vertical” becomes “horizontal.”</p>
            <p>So sin and cos trade identities under complementary angles.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, coMode:true},
        html:`
          <p><strong>Math:</strong></p>
          <div class="box">
            <p class="mono">sin(θ) = cos(90° − θ)</p>
            <p class="mono">cos(θ) = sin(90° − θ)</p>
          </div>
          <div class="box bad">
            <p><strong>SAT trap:</strong> people see “cos” and panic.</p>
            <p>It’s the same ratio with a swapped angle label.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, coMode:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              If <span class="mono">sin(x)=3/5</span> and x is acute, what is <span class="mono">cos(90°−x)</span>?
            </div>
            <div class="map">
              <p><strong>Identity:</strong> <span class="mono">cos(90°−x)=sin(x)</span></p>
              <p><strong>Answer:</strong> <span class="mono">3/5</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"word",
    nav:"7 Word Problems",
    title:"Word problems: same triangle, different nouns",
    subtitle:"SAT swaps words to make you forget it’s trig. Don’t.",
    layers:[
      { flags:{scene:"word", circle:false, triangle:true, projections:true, labels:false, walls:false, quadrants:false, wordScene:true},
        html:`
          <p><strong>Visual:</strong> height, ground distance, line-of-sight.</p>
          <div class="box">
            <p>Nothing changed. Only the nouns changed.</p>
            <p>Trig is still “angle + right triangle.”</p>
          </div>
        `
      },
      { flags:{scene:"word", circle:false, triangle:true, projections:true, labels:true, walls:false, quadrants:false, wordScene:true},
        html:`
          <p><strong>Concept mapping (SAT translation):</strong></p>
          <div class="box ok">
            <ul>
              <li><strong>Height</strong> → Opp (usually)</li>
              <li><strong>Ground distance</strong> → Adj (usually)</li>
              <li><strong>Ladder/cable</strong> → Hyp (usually)</li>
            </ul>
          </div>
          <div class="box bad">
            <p><strong>Angle of depression:</strong> same angle as elevation (alternate interior angles).</p>
            <p>They’re baiting panic. Don’t give it to them.</p>
          </div>
        `
      },
      { flags:{scene:"word", circle:false, triangle:true, projections:true, labels:true, walls:false, quadrants:false, wordScene:true},
        html:`
          <p><strong>Math patterns SAT repeats:</strong></p>
          <div class="box">
            <p class="mono">height = distance · tan θ</p>
            <p class="mono">height = hypotenuse · sin θ</p>
          </div>
          <p>You choose based on which length is given.</p>
        `
      },
      { flags:{scene:"word", circle:false, triangle:true, projections:true, labels:true, walls:false, quadrants:false, wordScene:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              From a point 80 m from a building, the angle of elevation is 28°. Approximately how tall is the building?
            </div>
            <div class="map">
              <ul>
                <li>Adj = 80 (ground distance)</li>
                <li>Opp = height</li>
              </ul>
              <p><strong>Use:</strong> <span class="mono">tan = Opp/Adj</span></p>
              <p><strong>Build:</strong> <span class="mono">height = 80·tan(28°)</span></p>
            </div>
          </div>
        `
      }
    ]
  },

  {
    id:"rad",
    nav:"8 Radians & Arcs",
    title:"Radians: the natural unit of rotation",
    subtitle:"On the unit circle, θ is literally arc length. That’s why radians exist.",
    layers:[
      { flags:{scene:"circle", circle:true, triangle:false, projections:false, labels:false, walls:false, quadrants:false, arcMode:true},
        html:`
          <p><strong>Visual:</strong> look at the highlighted arc on the circle.</p>
          <div class="box">
            <p>Degrees are a human invention: 360 pieces.</p>
            <p>Radians are physics: angle measured by arc length.</p>
          </div>
          <p class="tag">Unit circle = radius 1 = arc length equals angle (in radians).</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, arcMode:true},
        html:`
          <p><strong>Concept:</strong> angle = (arc length) / (radius).</p>
          <div class="box ok">
            <p>If radius = 1, then:</p>
            <p class="mono"><strong>θ (radians) = arc length</strong></p>
          </div>
          <p>This is why π shows up: it’s the half-circle arc length when radius = 1.</p>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, arcMode:true},
        html:`
          <p><strong>Math:</strong></p>
          <div class="box">
            <p class="mono">arc length: s = rθ</p>
            <p class="mono">sector area: A = (1/2)r²θ</p>
          </div>
          <div class="box bad">
            <p><strong>SAT trap:</strong> using degrees inside these formulas.</p>
            <p>These formulas demand θ in radians.</p>
          </div>
        `
      },
      { flags:{scene:"circle", circle:true, triangle:true, projections:true, labels:true, walls:false, quadrants:false, arcMode:true},
        html:`
          <div class="sat">
            <div class="q">SAT look:</div>
            <div class="a">
              A circle has radius 6. A sector has central angle <span class="mono">π/3</span>. What is the arc length?
            </div>
            <div class="map">
              <p><strong>Use:</strong> <span class="mono">s = rθ</span></p>
              <p><strong>Compute:</strong> <span class="mono">s = 6 · (π/3) = 2π</span></p>
            </div>
          </div>
        `
      }
    ]
  }
];

/* =========================================================
   Micro-quiz bank (one per lesson, fired on SAT layer)
   ========================================================= */
const quizBank = {
  unit: {
    q: "Point P is on the unit circle: P = (1/2, √3/2). What is θ?",
    choices: ["30°", "60°", "120°", "300°"],
    correct: 1
  },
  soh: {
    q: "In a right triangle, Opp = 8 and Hyp = 10. What is sin(θ)?",
    choices: ["4/5", "5/4", "3/5", "8/10 simplified is 8/10"],
    correct: 0
  },
  scale: {
    q: "Adj = 12 and tan(θ) = 3/4. What is Opp?",
    choices: ["9", "16", "4", "3"],
    correct: 0
  },
  special: {
    q: "What is sin(π/4)?",
    choices: ["1/2", "√2/2", "√3/2", "1"],
    correct: 1
  },
  quadrants: {
    q: "θ = 150°. What is sin(θ)?",
    choices: ["-1/2", "1/2", "-√3/2", "√3/2"],
    correct: 1
  },
  tan: {
    q: "A line makes angle θ with +x axis. If slope = -2, what is tan(θ)?",
    choices: ["2", "-2", "1/2", "-1/2"],
    correct: 1
  },
  co: {
    q: "If sin(x) = 3/5 and x is acute, what is cos(90° - x)?",
    choices: ["4/5", "3/5", "5/3", "1/5"],
    correct: 1
  },
  word: {
    q: "Ground distance = 20 and angle of elevation = θ. Height = 20·tan(θ). Which ratio did you use?",
    choices: ["sin = Opp/Hyp", "cos = Adj/Hyp", "tan = Opp/Adj", "cot = Adj/Opp"],
    correct: 2
  },
  rad: {
    q: "Radius r = 5, θ = 2π/5 (radians). What is arc length s?",
    choices: ["2π", "π/2", "10π", "5π/2"],
    correct: 0
  },
};

/* =========================================================
   UI wiring
   ========================================================= */
const nav = document.getElementById("nav");

function buildNav(){
  nav.innerHTML = "";
  lessons.forEach((L, i) => {
    const b = document.createElement("button");
    b.textContent = L.nav;
    b.onclick = () => setLesson(i);
    b.id = `nav_${i}`;
    nav.appendChild(b);
  });
}

function ensureProgress(lessonId){
  if(!progress[lessonId]) progress[lessonId] = { satPassed:false };
  return progress[lessonId];
}

function setLesson(i){
  state.lessonIndex = i;
  state.layerIndex = 0;
  state.unlockedLayer = 0;

  stopQuiz(); // hard stop on lesson change
  updatePanel(); updateNav(); draw(); updateHud();
}

function setLayer(k){
  if(state.uiLocked) return;
  if(k > state.unlockedLayer) return;

  state.layerIndex = k;

  // Fire quiz if SAT layer and not passed
  const lesson = lessons[state.lessonIndex];
  const prog = ensureProgress(lesson.id);
  if(state.layerIndex === 3 && !prog.satPassed){
    updatePanel(); draw(); updateHud();
    startQuizForLesson(lesson.id);
    return;
  }

  updatePanel(); draw(); updateHud();
}

function nextLayer(){
  if(state.uiLocked) return;
  if(state.layerIndex < 3){
    state.unlockedLayer = Math.max(state.unlockedLayer, state.layerIndex + 1);
    state.layerIndex++;

    const lesson = lessons[state.lessonIndex];
    const prog = ensureProgress(lesson.id);
    if(state.layerIndex === 3 && !prog.satPassed){
      updatePanel(); draw(); updateHud();
      startQuizForLesson(lesson.id);
      return;
    }

    updatePanel(); draw(); updateHud();
  }
}
function prevLayer(){
  if(state.uiLocked) return;
  if(state.layerIndex > 0){
    state.layerIndex--;
    updatePanel(); draw(); updateHud();
  }
}
function nextLesson(){ if(state.uiLocked) return; if(state.lessonIndex < lessons.length-1) setLesson(state.lessonIndex+1); }
function prevLesson(){ if(state.uiLocked) return; if(state.lessonIndex > 0) setLesson(state.lessonIndex-1); }

function updateNav(){
  lessons.forEach((_, i) => {
    const b = document.getElementById(`nav_${i}`);
    if(b) b.classList.toggle("active", i === state.lessonIndex);
  });
}

function updatePanel(){
  const L = lessons[state.lessonIndex];
  const layer = L.layers[state.layerIndex];

  document.getElementById("title").textContent = L.title;
  document.getElementById("subtitle").textContent = L.subtitle;
  document.getElementById("body").innerHTML = layer.html;

  for(let k=0;k<4;k++){
    const btn = document.getElementById(`layer${k}`);
    btn.classList.toggle("active", k === state.layerIndex);
    const locked = k > state.unlockedLayer;
    btn.classList.toggle("locked", locked);
    btn.disabled = locked || state.uiLocked;
  }

  document.getElementById("btnBackLayer").disabled = state.layerIndex === 0 || state.uiLocked;
  document.getElementById("btnForwardLayer").disabled = state.layerIndex === 3 || state.uiLocked;
  document.getElementById("btnPrev").disabled = state.lessonIndex === 0 || state.uiLocked;
  document.getElementById("btnNext").disabled = state.lessonIndex === lessons.length-1 || state.uiLocked;
}

window.setLayer = setLayer;
window.nextLayer = nextLayer;
window.prevLayer = prevLayer;
window.nextLesson = nextLesson;
window.prevLesson = prevLesson;

/* =========================================================
   Controls
   ========================================================= */
const btnReadout = document.getElementById("btnReadout");
const btnSnap = document.getElementById("btnSnap");

btnReadout.addEventListener("click", () => {
  if(state.uiLocked) return;
  state.readout = !state.readout;
  btnReadout.classList.toggle("active", state.readout);
  draw();
});
btnSnap.addEventListener("click", () => {
  if(state.uiLocked) return;
  state.snap = !state.snap;
  btnSnap.classList.toggle("active", state.snap);
  draw(); updateHud();
});

/* =========================================================
   Quiz system
   ========================================================= */
const quizOverlay = document.getElementById("quizOverlay");
const quizQ = document.getElementById("quizQ");
const quizChoices = document.getElementById("quizChoices");
const quizResult = document.getElementById("quizResult");
const quizBar = document.getElementById("quizBar");
const quizTime = document.getElementById("quizTime");

function lockUI(on){
  state.uiLocked = on;
  // disable layer buttons and nav buttons
  document.querySelectorAll("#nav button").forEach(b => b.disabled = on);
  document.querySelectorAll("#layers button").forEach(b => b.disabled = on || b.classList.contains("locked"));
  document.querySelectorAll("#panelBottom button").forEach(b => b.disabled = on || b.disabled);

  btnReadout.disabled = on;
  btnSnap.disabled = on;
  // visual dim optional: not needed; overlay handles it
  updatePanel();
}

function startQuizForLesson(lessonId){
  const item = quizBank[lessonId];
  if(!item){
    // No quiz defined => auto pass.
    ensureProgress(lessonId).satPassed = true;
    return;
  }

  stopQuiz();
  state.quizActive = true;
  lockUI(true);

  quizOverlay.classList.add("active");
  quizResult.textContent = "";
  quizResult.className = "";
  quizQ.textContent = item.q;

  quizChoices.innerHTML = "";
  item.choices.forEach((c, idx) => {
    const b = document.createElement("button");
    b.className = "choice";
    b.innerHTML = `<span class="mono">${String.fromCharCode(65+idx)})</span> ${c}`;
    b.onclick = () => resolveQuiz(idx);
    quizChoices.appendChild(b);
  });

  state.quizEndsAt = Date.now() + state.quizDurationMs;

  // timer tick
  state.quizTimer = setInterval(() => {
    const now = Date.now();
    const left = state.quizEndsAt - now;
    const frac = clamp(left / state.quizDurationMs, 0, 1);

    quizBar.style.width = `${(frac*100).toFixed(1)}%`;
    quizBar.style.background = frac > 0.33 ? "rgba(34,197,94,0.85)" : "rgba(239,68,68,0.85)";
    quizTime.textContent = `${(left/1000).toFixed(1)}s`;

    if(left <= 0){
      failQuiz("Time.");
    }
  }, 80);
}

function resolveQuiz(choiceIdx){
  if(!state.quizActive) return;
  const lessonId = lessons[state.lessonIndex].id;
  const item = quizBank[lessonId];
  if(!item) return;

  // freeze choices
  quizChoices.querySelectorAll("button").forEach(b => b.disabled = true);

  if(choiceIdx === item.correct){
    passQuiz();
  } else {
    failQuiz("Wrong.");
  }
}

function passQuiz(){
  if(!state.quizActive) return;
  const lessonId = lessons[state.lessonIndex].id;
  ensureProgress(lessonId).satPassed = true;

  quizResult.textContent = "Correct. You can see SAT now.";
  quizResult.className = "good";

  setTimeout(() => {
    stopQuiz();
    // keep SAT unlocked
    state.unlockedLayer = Math.max(state.unlockedLayer, 3);
    updatePanel(); draw(); updateHud();
  }, 650);
}

function failQuiz(reason){
  if(!state.quizActive) return;

  quizResult.textContent = `${reason} Back one step.`;
  quizResult.className = "bad";

  setTimeout(() => {
    stopQuiz();

    // kick back one layer and lock SAT again
    state.layerIndex = Math.max(0, state.layerIndex - 1);
    state.unlockedLayer = Math.min(state.unlockedLayer, 2);

    updatePanel(); draw(); updateHud();
  }, 850);
}

function stopQuiz(){
  if(state.quizTimer){
    clearInterval(state.quizTimer);
    state.quizTimer = null;
  }
  state.quizActive = false;
  quizOverlay.classList.remove("active");
  lockUI(false);

  // reset bar/time display
  quizBar.style.width = "100%";
  quizBar.style.background = "rgba(34,197,94,0.85)";
  quizTime.textContent = `${(state.quizDurationMs/1000).toFixed(1)}s`;
}

/* =========================================================
   Scene geometry
   ========================================================= */
function currentFlags(){
  return lessons[state.lessonIndex].layers[state.layerIndex].flags;
}
function getSceneAnchor(flags){
  if(flags.scene !== "word"){
    return {ox: state.baseCx, oy: state.baseCy, R: state.baseR};
  }
  const ox = state.w*0.22;
  const oy = state.h*0.78;
  const R  = Math.min(state.w, state.h)*0.30;
  return {ox, oy, R};
}

/* =========================================================
   Input
   ========================================================= */
function interact(px, py){
  if(state.uiLocked) return;

  const flags = currentFlags();
  const {ox, oy} = getSceneAnchor(flags);

  const dx = px - ox;
  const dy = py - oy;
  let ang = Math.atan2(-dy, dx);

  if(flags.scene === "word"){
    ang = clamp(ang, degToRad(5), degToRad(80));
  }

  state.theta = ang;

  if(state.snap){
    const d = normDeg(radToDeg(state.theta));
    const {best, dist} = nearestSpecialDeg(d);
    if(dist < 1.8) state.theta = degToRad(best);
  }

  draw(); updateHud();
}

cvs.addEventListener("mousedown", e => {
  state.dragging = true;
  interact(e.offsetX, e.offsetY);
});
window.addEventListener("mousemove", e => {
  if(!state.dragging) return;
  const r = cvs.getBoundingClientRect();
  interact(e.clientX - r.left, e.clientY - r.top);
});
window.addEventListener("mouseup", () => state.dragging=false);

cvs.addEventListener("touchstart", e => {
  e.preventDefault();
  state.dragging = true;
  const r = cvs.getBoundingClientRect();
  interact(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
}, {passive:false});

cvs.addEventListener("touchmove", e => {
  e.preventDefault();
  if(!state.dragging) return;
  const r = cvs.getBoundingClientRect();
  interact(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
}, {passive:false});

cvs.addEventListener("touchend", () => state.dragging=false);

/* =========================================================
   Resize
   ========================================================= */
function resize(){
  const p = cvs.parentElement;
  state.w = p.clientWidth;
  state.h = p.clientHeight;
  cvs.width = state.w;
  cvs.height = state.h;

  state.baseCx = state.w * 0.38;
  state.baseCy = state.h * 0.64;
  state.baseR  = Math.min(state.w, state.h) * 0.30;

  draw(); updateHud();
}
window.addEventListener("resize", resize);

/* =========================================================
   HUD
   ========================================================= */
function effectiveTheta(flags){
  if(flags.scene === "word"){
    return clamp(state.theta, degToRad(5), degToRad(80));
  }
  return state.theta;
}
function updateHud(){
  const flags = currentFlags();
  const th = effectiveTheta(flags);

  const rawDeg = radToDeg(th);
  const eqDeg = normDeg(rawDeg);
  const ref = referenceAngleDeg(eqDeg);
  const quad = quadrantFromDeg(eqDeg);

  const piForm = degToPiFrac(eqDeg);
  document.getElementById("hudTheta").textContent = `θ = ${rawDeg.toFixed(0)}° (${piForm})`;
  document.getElementById("hudEq").textContent = `Equivalent: ${eqDeg.toFixed(0)}°`;
  document.getElementById("hudQuad").textContent = quad;
  document.getElementById("hudRef").textContent = `ref ${ref.toFixed(0)}° (${degToPiFrac(ref)})`;

  const qPill = document.getElementById("hudQuad");
  qPill.classList.remove("ok","bad");
  qPill.classList.add(quad.startsWith("Axis") ? "bad" : "ok");
}

/* =========================================================
   Drawing engine
   ========================================================= */
function draw(){
  if(state.w === 0 || state.h === 0) return;

  const flags = currentFlags();
  const {ox, oy, R} = getSceneAnchor(flags);
  const th = effectiveTheta(flags);

  ctx.fillStyle = colors.bg;
  ctx.fillRect(0,0,state.w,state.h);

  if(flags.scene === "word"){
    drawWordScene(ox, oy, R, th, flags);
    return;
  }

  drawAxes(ox, oy);
  if(flags.quadrants) shadeQuadrants(ox, oy, R);
  if(flags.circle) drawCircle(ox, oy, R);

  const px = ox + R * Math.cos(th);
  const py = oy - R * Math.sin(th);

  if(flags.triangle) drawTriangle(ox, oy, px, py, R, th, flags);
  else drawRadius(ox, oy, px, py, R, th, flags);

  if(flags.walls) drawTanWall(ox, oy, R, th);
  if(flags.arcMode) drawArcHighlight(ox, oy, R, th);

  if(state.readout) drawMicroReadout(ox, oy, px, py, th, flags);
}

/* ---------- primitives ---------- */
function drawAxes(cx, cy){
  ctx.strokeStyle = colors.grid;
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(state.w, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, state.h); ctx.stroke();
}
function drawCircle(cx, cy, R){
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(cx, cy, R, 0, TAU); ctx.stroke();
}
function shadeQuadrants(cx, cy, R){
  ctx.save();
  ctx.beginPath(); ctx.arc(cx,cy,R,0,TAU); ctx.clip();
  ctx.globalAlpha = 0.10;
  ctx.fillStyle = colors.ok;  ctx.fillRect(cx, cy-R, R, R);     // QI
  ctx.fillStyle = colors.cos; ctx.fillRect(cx-R, cy-R, R, R);   // QII
  ctx.fillStyle = colors.sin; ctx.fillRect(cx-R, cy, R, R);     // QIII
  ctx.fillStyle = colors.tan; ctx.fillRect(cx, cy, R, R);       // QIV
  ctx.restore();
}
function neon(x1,y1,x2,y2,color,width=3){
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
  ctx.lineWidth = width*4;
  ctx.strokeStyle = color;
  ctx.globalAlpha = 0.22;
  ctx.stroke();
  ctx.lineWidth = width;
  ctx.globalAlpha = 1;
  ctx.strokeStyle = color;
  ctx.stroke();
}
function dashed(x1,y1,x2,y2,color){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.setLineDash([6,6]);
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}
function dot(x,y,r,color){
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
}
function label(x,y,text,color){
  ctx.save();
  ctx.font = "980 12px Segoe UI, system-ui, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  const pad=6;
  const w = ctx.measureText(text).width + pad*2;
  ctx.fillStyle = "rgba(0,0,0,0.72)";
  ctx.fillRect(x-w/2, y-10, w, 20);
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.strokeRect(x-w/2, y-10, w, 20);
  ctx.fillStyle = color;
  ctx.fillText(text, x, y);
  ctx.restore();
}
function rightAngle(x,y,size){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.55)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x - size, y);
  ctx.lineTo(x - size, y - size);
  ctx.lineTo(x, y - size);
  ctx.stroke();
  ctx.restore();
}
function laser(x1,y1,x2,y2){
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(255,255,255,0.9)";
  ctx.setLineDash([6,6]);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.lineWidth = 10;
  ctx.strokeStyle = "rgba(255,255,255,0.14)";
  ctx.stroke();
  ctx.restore();
  dot(x2,y2,4,"#fff");
}
function angleArc(cx, cy, theta, r){
  const t = thetaSignedForArc(theta);
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.65)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  const end = -t;
  if(t >= 0){ ctx.arc(cx, cy, r, 0, end, true); }
  else { ctx.arc(cx, cy, r, 0, end, false); }
  ctx.stroke();
  ctx.restore();
}

/* ---------- scene drawing ---------- */
function drawRadius(cx, cy, px, py, R, theta){
  neon(cx, cy, px, py, colors.white, 3);
  dot(px, py, 6, "#fff");
  angleArc(cx, cy, theta, R*0.18);
}
function drawTriangle(cx, cy, px, py, R, theta, flags){
  neon(cx, cy, px, cy, colors.cos, flags.showOppAdjHyp ? 4 : 3);
  neon(px, cy, px, py, colors.sin, flags.showOppAdjHyp ? 4 : 3);
  neon(cx, cy, px, py, colors.white, flags.showOppAdjHyp ? 4 : 3);

  dot(px, py, 6, "#fff");
  angleArc(cx, cy, theta, R*0.16);

  if(flags.projections){
    dashed(px, py, px, cy, "rgba(0,204,255,0.45)");
    dashed(px, py, cx, py, "rgba(255,0,85,0.45)");
  }

  if(flags.labels){
    if(flags.showOppAdjHyp){
      label((cx+px)/2, cy+18, "Adj", colors.cos);
      label(px+28, (cy+py)/2, "Opp", colors.sin);
      label((cx+px)/2+12, (cy+py)/2-12, "Hyp", "#fff");
    } else {
      label((cx+px)/2, cy+18, "cos θ", colors.cos);
      label(px+30, (cy+py)/2, "sin θ", colors.sin);
      label((cx+px)/2+10, (cy+py)/2-12, "radius", "#fff");
    }
  }

  rightAngle(px, cy, 14);

  if(flags.scaleDemo){
    const scale = 1.45;
    const gx = cx + (px-cx)*scale;
    const gy = cy + (py-cy)*scale;
    ctx.save();
    ctx.globalAlpha = 0.22;
    neon(cx, cy, gx, cy, colors.cos, 3);
    neon(gx, cy, gx, gy, colors.sin, 3);
    neon(cx, cy, gx, gy, colors.white, 3);
    ctx.restore();
    label((cx+gx)/2, cy-20, "Same θ, bigger triangle", colors.ok);
  }

  if(flags.specialMode){
    drawSpecialTicks(cx, cy, R);
  }

  if(flags.coMode){
    label(px-10, py+26, "90°−θ", "#ddd");
  }
}
function drawSpecialTicks(cx, cy, R){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.15)";
  ctx.lineWidth = 1;
  for(const d of [0,30,45,60,90,120,135,150,180,210,225,240,270,300,315,330]){
    const a = degToRad(d);
    const x1 = cx + Math.cos(a)*(R*0.92);
    const y1 = cy - Math.sin(a)*(R*0.92);
    const x2 = cx + Math.cos(a)*(R*1.02);
    const y2 = cy - Math.sin(a)*(R*1.02);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  ctx.restore();
}
function drawTanWall(cx, cy, R, theta){
  const wallX = cx + R;
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(wallX, cy+60); ctx.lineTo(wallX, cy-state.h); ctx.stroke();

  const c = Math.cos(theta);
  if(Math.abs(c) < 1e-5){
    label(wallX+64, cy-90, "tan undefined", colors.bad);
    return;
  }

  const t = Math.tan(theta);
  if(Math.abs(t) > 8){
    label(wallX+64, cy-90, "tan huge", colors.bad);
    laser(cx, cy, wallX, cy - clamp(R*t, -R*3, R*3));
    return;
  }

  const tanY = cy - R*t;
  neon(wallX, cy, wallX, tanY, colors.tan, 4);
  laser(cx, cy, wallX, tanY);
  label(wallX+42, (cy+tanY)/2, "tan θ", colors.tan);
}
function drawArcHighlight(cx, cy, R, theta){
  const t = thetaSignedForArc(theta);
  const start = 0;
  const end = -t;

  ctx.save();
  ctx.lineWidth = 10;
  ctx.strokeStyle = "rgba(34,197,94,0.35)";
  ctx.beginPath();
  if(t >= 0){ ctx.arc(cx, cy, R, start, end, true); }
  else { ctx.arc(cx, cy, R, start, end, false); }
  ctx.stroke();
  ctx.restore();

  label(cx + R*0.25, cy - R*0.12, "arc", colors.ok);
}
function drawMicroReadout(cx, cy, px, py, theta, flags){
  const s = Math.sin(theta), c = Math.cos(theta);
  const t = (Math.abs(c)<1e-6) ? Infinity : s/c;

  let x = px + 16;
  let y = py - 18;
  x = Math.max(12, Math.min(state.w-190, x));
  y = Math.max(18, Math.min(state.h-18, y));

  const lines = [];
  if(flags.circle || flags.triangle){
    lines.push({k:"sin", v:fmt(s), c:colors.sin});
    lines.push({k:"cos", v:fmt(c), c:colors.cos});
  }
  if(flags.walls || flags.scene==="word"){
    lines.push({k:"tan", v:(Number.isFinite(t)?fmt(t):"undef"), c:colors.tan});
  }

  const d = normDeg(radToDeg(theta));
  const snapInfo = nearestSpecialDeg(d);
  const isExact = (snapInfo.dist < 0.2);
  if(isExact && (flags.specialMode || flags.arcMode || flags.scene==="circle")){
    const ex = exactFromDeg(snapInfo.best);
    if(ex){
      lines.push({k:"sin*", v:ex.sin, c:"rgba(255,0,85,0.9)"});
      lines.push({k:"cos*", v:ex.cos, c:"rgba(0,204,255,0.9)"});
      if(flags.walls) lines.push({k:"tan*", v:ex.tan, c:"rgba(255,204,0,0.9)"});
      lines.push({k:"rad", v:degToPiFrac(snapInfo.best), c:"rgba(255,255,255,0.85)"});
    }
  }

  if(lines.length === 0) return;

  const pad=8, lh=16, w=172, h=pad*2 + lh*lines.length;

  ctx.fillStyle = "rgba(0,0,0,0.70)";
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;
  roundRect(x, y, w, h, 10, true, true);

  ctx.font = "900 12px ui-monospace, Menlo, Consolas, monospace";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";

  for(let i=0;i<lines.length;i++){
    const yy = y + pad + i*lh + lh/2;
    ctx.fillStyle = lines[i].c;
    ctx.fillText(lines[i].k.toUpperCase(), x+10, yy);
    ctx.fillStyle = "#ddd";
    ctx.fillText(lines[i].v, x+66, yy);
  }
}
function roundRect(x, y, w, h, r, fill, stroke){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* ---------- Word scene ---------- */
function drawWordScene(ox, oy, R, theta, flags){
  const w=state.w;

  ctx.strokeStyle = "#333";
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(w, oy); ctx.stroke();

  const baseX = ox + R*1.2;
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 6;
  ctx.beginPath(); ctx.moveTo(baseX, oy); ctx.lineTo(baseX, oy - R*1.1); ctx.stroke();

  const hypLen = R*1.15;
  const hx = ox + hypLen*Math.cos(theta);
  const hy = oy - hypLen*Math.sin(theta);

  neon(ox, oy, baseX, oy, colors.cos, 4);
  neon(baseX, oy, baseX, hy, colors.sin, 4);
  neon(ox, oy, baseX, hy, colors.white, 4);

  dot(ox, oy, 6, "#fff");
  dot(baseX, hy, 6, "#fff");

  angleArc(ox, oy, theta, 26);

  if(flags.labels){
    label((ox+baseX)/2, oy+18, "Ground (Adj)", colors.cos);
    label(baseX+62, (oy+hy)/2, "Height (Opp)", colors.sin);
    label((ox+baseX)/2+20, (oy+hy)/2-12, "Line of sight (Hyp)", "#fff");
  }
}

/* =========================================================
   Boot
   ========================================================= */
buildNav();
setLesson(0);
setTimeout(resize, 20);
resize();
</script>

</body>
</html>
